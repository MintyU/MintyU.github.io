{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## Google Class 과제 할당\n\nGoogle Class 강의실에서 과제를 할당하는 방법입니다.\n\n![](1.png)\n\n123이라는 제목의 수업을 임의로 만들었습니다.\n\n왼쪽 중단에 표시되는 과제 부분에 과제가 없다고 표시되고 있습니다.\n\n그럼 이 수업을 듣는 학생들에게 과제를 할당해봅시다!\n\n위쪽 탭에서 스트림 옆의 '수업' 탭을 클릭합니다.\n\n그럼 아래와 같은 화면으로 넘어가게 됩니다.\n\n![](2.png)\n\n이 화면에서, 색칠이 되어있는 '만들기' 버튼을 클릭하면 아래와 같이 과제를 만들 수 있습니다.\n\n![](3.png)\n\n![](4.png)\n\n과제를 설정하는 화면입니다.\n\n과제를 누르고 다음 화면으로 넘어오면 과제 제목과 안내사항(선택사항)을 입력할 수 있습니다.\n\n우측에는 과제의 기한을 설정할 수 있습니다.\n\n설정이 완료되었다면 우측 상단에 과제 만들기 버튼을 클릭하면 과제 할당이 완료됩니다.\n\n![](5.png)\n\n성공적으로 과제가 할당되었습니다! 이 화면에서는 학생들이 과제가 성공적으로 제출되었는지를 확인할 수 있습니다.","excerpt":"Google Class 과제 할당 Google Class 강의실에서 과제를 할당하는 방법입니다.  12…","fields":{"slug":"/googleclass.md/"},"frontmatter":{"date":"Mar 20, 2020","title":"Google Class에서 과제 할당하기","tags":["Google Class"]}}},{"node":{"rawMarkdownBody":"\nMAC OS를 사용하는 경우, iTerm에서 VSCode를 간단한 명령어로 호출할 수 있습니다.\n\n다음과 같이 열고자 하는 디렉토리 내에서 `code .`라는 명령어를 입력해주면 현재 경로로 VSCode가 실행됩니다.\n\n![Terminalexample](1.png)\n\n## Setting\n\n하지만, 이를 위해선 간단한 세팅을 해 주어야 합니다.\n\n먼저, 현재 저는 iTerm2 Terminal에 oh-my-zsh를 사용하고 있음을 밝힙니다.\n\n저처럼 iTerm2에 oh-my-zsh 세팅까지 모두 끝냈다면 ~/.zshrc를 편집하는 방법은 알고 있겠지만, 모른다 하더라도 어렵지는 않습니다.\n\niTerm2 터미널을 열고, 다음과 같이 입력합니다.\n\n```\n$ vim ~/.zshrc\n```\n\n위 명령어를 입력했다면, 다음과 같은 화면을 볼 수 있습니다.\n\n![vim](2.png)\n\nShift + g를 눌러 문서의 맨 아래로 이동한 후, o(아랫줄에 insert)를 눌러 편집모드를 켭니다.\n\n그리고 다음과 같이 입력해줍니다.\n\n```\ncode () {VSCODE_CWD=\"$PWD\" open -n -b \"com.microsoft.VSCode\" --args $* ;}\n```\n\n입력이 되었다면, esc버튼을 눌러 편집 모드를 끝낸 뒤에(왼쪽 아래 normal 확인),\n\n:wq를 입력하여 저장하고 나가줍니다.(\":\"을 누르면 명령어 입력창이 활성화됩니다.)\n\n그 후 터미널에서 다음과 같이 `source ~/.zshrc`를 입력하면 터미널에서 명령어를 통해 VSCode를 실행할 수 있게 됩니다!\n\n![source](3.png)","excerpt":"MAC OS를 사용하는 경우, iTerm에서 VSCode를 간단한 명령어로 호출할 수 있습니다. 다음과 같이 열고자 하는 디렉토리 내에서 라는 명령어를 입력해주면 현재 경로로 VSCode가 실행됩니다.  Setting…","fields":{"slug":"/VSCodeShortCut.md/"},"frontmatter":{"date":"Mar 06, 2020","title":"iTerm(Using Zsh)에서 VSCode 열기 [MAC OS]","tags":["MAC"]}}},{"node":{"rawMarkdownBody":"\n## 반복문(Iteration Statements)\n\n반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문입니다.\n\n프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나입니다.\n\n \n\nC++에서 사용되는 대표적인 반복문의 형태는 다음과 같습니다.\n\n \n\n1. while 문\n\n2. do / while 문\n\n3. for 문\n\n4. 범위 기반의 for 문\n\n### while 문\n\nwhile 문은 특정 조건을 만족하는 한 계속해서 주어진 명령문을 반복 실행합니다.\n\n\nC++에서 while 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> while (조건식)\n> \n> {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n### do / while 문\n\nwhile 문은 루프에 진입하기 전에 먼저 조건식부터 검사합니다.\n\n하지만 do / while 문은 먼저 루프를 한 번 실행한 후에 조건식을 검사합니다.\n\n즉, do / while 문은 조건식의 결과와 상관없이 무조건 한 번은 루프를 실행합니다.\n\n \n\nC++에서 do / while 문의 문법은 다음과 같습니다.\n\n> 문법\n> ```cpp\n> do {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> } while (조건식);\n> ```\n\n### for 문\n\nwhile 문은 우선 조건식이 참(true)인지를 판단하여, 참이면 내부의 명령문을 실행합니다.\n\n내부의 명령문을 전부 실행하고 나면, 다시 조건식으로 돌아와 또 한 번 참인지를 판단하게 됩니다.\n\nfor 문은 while 문과는 달리 자체적으로 초기식, 조건식, 증감식을 모두 포함하고 있는 반복문입니다.\n\n따라서 while 문보다는 좀 더 간결하게 반복문을 표현할 수 있습니다.\n\n \n\nC++에서 for 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> for (초기식; 조건식; 증감식)\n> \n> {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n### 범위 기반의 for 문\n\nC++11부터는 범위 기반의 for 문이라는 새로운 형태의 반복문이 추가되었습니다.\n\n범위 기반의 for 문은 표현식 안에 포함되어 있는 모든 값에 대해 한 번씩 루프를 실행해 줍니다.\n\n \n\n이러한 범위 기반의 for 문은 배열을 자동으로 인식하며, 컨테이너 클래스에서 많이 사용됩니다.\n\n \n\n다음 예제는 범위 기반의 for 문을 사용하여 배열의 모든 값을 출력하는 예제입니다.\n\n> 예제\n> ```cpp\n> int arr[5] = {1, 3, 5, 7, 9};\n> \n>  \n> \n> for (int element : arr)\n> \n> {\n> \n>     cout << element << \" \";\n> \n> }\n> \n> // 1 3 5 7 9\n> ```\n\n\n## 루프 제어\n\n일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행합니다.\n\n하지만 continue 문과 break 문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 도와줍니다.\n\n\n### continue 문\n\ncontinue 문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 해줍니다.\n\n보통 반복문 내에서 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용됩니다.\n\n \n\n다음 예제는 1부터 100까지의 정수 중에서 짝수를 제외하고 홀수만을 출력하는 예제입니다.\n\n> 예제\n> ```cpp\n> int except_num = 2\n> \n>  \n> \n> for (int i = 0; i <= 100; i++)\n> \n> {\n> \n>     if (i % except_num == 0)\n> \n>     {\n> \n>         continue;\n> \n>     }\n> \n>     cout << i << \" \";\n> \n> }\n> // 1 3 5 7 9 ... 97 99\n> ```\n\n### break 문\n\nbreak 문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행합니다.\n\n즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용합니다.\n\n \n\n다음 예제는 1부터 사용자가 입력한 정수까지의 합을 구하는 예제입니다.\n \n> 예제\n> ```cpp\n> int num = 1, sum = 0;\n> int end_num = 10;\n> \n>  \n> \n> while (1) // 무한 루프\n> \n> {\n> \n>     sum += num;\n> \n>     if (num == end_num)\n> \n>     {\n> \n>         break;\n> \n>     }\n> \n>     num++;\n> \n> }\n> \n> cout << \"1부터 \" << end_num << \"까지 더한 값은 \" << sum << \"입니다.\";\n> \n> //1부터 10까지 더한 값은 55입니다.\n> ```\n\n","excerpt":"반복문(Iteration Statements…","fields":{"slug":"/cpp08.md/"},"frontmatter":{"date":"Mar 05, 2020","title":"바닥에서 시작하는 C++ (8) - 반복문","tags":["C++"]}}},{"node":{"rawMarkdownBody":"\n## 문제\n\n피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.\n\n이를 식으로 써보면 F(n) = F(n-1) + F(n-2) (n>=2)가 된다.\n\nn = 17일때 까지 피보나치 수를 써보면 다음과 같다.\n\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597\n\nn이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 n이 주어진다. n은 45보다 작거나 같은 자연수이다.\n\n## 출력\n\n첫째 줄에 n번째 피보나치 수를 출력한다.\n\n#### <예제 입력 1>\n\n`10`\n\n#### <예제 출력 1> \n\n`55`\n\n\n## 풀이\n\n다이나믹 프로그래밍(DP)의 가장 대표적인 문제라고 할 수 있는 문제이다.\n\n규칙에 맞게 피보나치 수를 구해서 출력하기만 하면 되는 간단한 문제이다.\n\n피보나치 수는 앞의 두 수의 합이므로 `fib(a)`가 a번째 피보나치 수라고 가정하였을 때,\n\n`fib(a) = fib(a-1) + fib(a-2)`가 된다.\n\n따라서, 다음과 같이 재귀형으로 함수를 호출하며 피보나치 수를 구할 수 있다.\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nint fib(int a) {\n\n    switch (a)\n    {\n    \n    case 0:\n        return 0;\n        break;\n    \n    case 1:\n        return 1;\n        break;\n    \n    \n    default:\n        return fib(a-1) + fib(a-2);\n        break;\n    }\n\n}\n\nint main() {\n\n    int a;\n    \n    cin >> a;\n    \n    cout << fib(a);\n    \n    return 0;\n}\n```\n\n위 예제를 실행하고 `1, 2, 3, 4` 등을 입력하면 정상적으로 `1, 1, 2, 3`이 출력되는것을 확인할 수 있다.\n\n하지만, 문제의 입력 조건의 최댓값으로 주어진 `45`를 입력해보자.\n\n문제의 답이 출력되긴 하지만, 제한시간인 1초를 훨씬 넘겨서 뒤늦게 답이 출력되는 것을 볼 수 있다.\n\n따라서 위의 예제처럼 작성하여 제출하게 되면 다음처럼 제한시간이 초과된다.\n\n![시간 초과](1.png)\n\n그 이유는, 피보나치 수를 계산하는 과정에서 했던 계산을 계속하기 때문이다.\n\n`fib(10)`을 예로 들어보자.\n\n`fib(10) = fib(9) + fib(8)`\n\n`fib(10) = (fib(8) + fib(7)) + (fib(7) + fib(6))`\n\n`fib(10) = ((fib(7) + fib(6)) + (fib(6) + fib(5)) + ((fib(6) + fib(5)) + (fib(4) + fib(3))`\n\n`...후략`\n\n계산은 아직 절반도 하지 않았는데, `fib(8)`은 2번, `fib(7)`은 3번, `fib(6)`은 4번이나 호출되었다.\n\n시간이 초과되지 않기 위해서는, 조금 근본적인 방법으로부터 접근할 필요가 있다.\n\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n\n    long long a[1000] = {0, 1, };\n\n    int count;\n\n    cin >> count;\n\n    for (int i = 2; i <= count; i++)\n    {\n\n        a[i] = a[i-1]+a[i-2];\n\n    }\n\n    cout << a[count];\n\n    return 0;\n}\n```\n\n\n위의 코드는 1차원 배열을 통해 함수를 재귀호출하지 않고 피보나치 수를 구한다.\n\n배열의 크기는 상관없기에 넉넉하게 잡았으며, 배열 안에 들어갈 수는 integer의 범위를 벗어날 수도 있기에 long long으로 설정해주었다.\n\n이 예제를 실행하고 45번째 피보나치 수를 구해도, 심지어 100번째 피보나치 수를 구한다 하더라도 즉각 답을 출력해주는 것을 볼 수 있다.\n\n","excerpt":"문제 피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. 이를 식으로 써보면 F(n) = F(n-1) + F(n-2) (n>=2)가 된다. n…","fields":{"slug":"/BOJ02747.md/"},"frontmatter":{"date":"Mar 02, 2020","title":"백준 [2747] - 피보나치 수(C++)","tags":["백준알고리즘(C++)"]}}},{"node":{"rawMarkdownBody":"\n## 조건문(Conditional Statements)\n\n조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문입니다.\n\n\nC++에서 사용하는 대표적인 조건문의 형태는 다음과 같습니다.\n\n \n\n1. if 문\n\n2. if / else 문\n\n3. if / else if / else 문\n\n4. switch 문\n\n### if 문\n\nif 문은 조건식의 결과가 참(true)이면 주어진 명령문을 실행하며, 거짓(false)이면 아무것도 실행하지 않습니다.\n\nC++에서 if문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식)\n> \n> {\n> \n>     조건식의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n위의 코드에서 블록에 속한 명령문은 중괄호({})를 기준으로 오른쪽으로 들여쓰기가 되어 있는 것을 볼 수 있습니다.\n\n이처럼 들여쓰기를 통해 코드의 가독성을 높이는 것을 인덴트(indent)라고 하며, 될 수 있으면 모든 코드를 인덴트하는 것이 좋습니다.\n\n### if / else 문\n\nif 문과 함께 사용하는 else 문은 if 문과는 반대로 주어진 조건식의 결과가 거짓(false)이면 주어진 명령문을 실행합니다.\n\n\nC++에서 if / else 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식)\n> \n> {\n> \n>     조건식의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else\n> \n> {\n> \n>     조건식의 결과가 거짓일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n위 식은 [여기](https://mintyu.github.io/cpp06.md/#%EC%82%BC%ED%95%AD-%EC%97%B0%EC%82%B0%EC%9E%90ternary-operator)에 설명했듯 아래 식처럼 삼항연산자를 통해 짧게 나타낼 수도 있습니다.\n> ``` cpp\n> 조건식 ? 반환값1(True) : 반환값2(False)\n> \n> ```\n\n### if / else if / else 문\n\nif / else if / else 문은 마치 새로운 구문처럼 보이지만, 사실은 두 개의 if / else 문이 연달아 나온 것뿐입니다.\n\n이러한 if / else if / else 문은 조건식을 여러 개 명시할 수 있으므로 중첩된 if 문을 좀 더 간결하게 표현할 수 있습니다.\n\nif / else if / else 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식1)\n> \n> {\n> \n>     조건식1의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else if (조건식2)\n> \n> {\n> \n>     조건식2의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else\n> \n> {\n> \n>     조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n**실행될 명령어가 한줄 뿐이라면 중괄호`{ }`를 생략해서 쓸 수 있습니다.**\n\n### switch 문\n\nswitch 문은 if / else 문과 마찬가지로 주어진 조건 값의 결과에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문입니다.\n\n이러한 switch 문은 if / else 문보다 가독성이 더 좋으며, 컴파일러가 최적화를 쉽게 할 수 있어 속도 또한 빠른 편입니다.\n\n하지만, switch 문의 조건 값으로는 char형, short형, int형 변수나 리터럴과 나중에 배우게 될 열거체까지 사용할 수 있습니다.\n\n따라서 if / else 문보다는 사용할 수 있는 상황이 적은 편입니다.\n\nC++에서 switch 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> switch (조건 값)\n> \n> {\n> \n>     case 값1:\n> \n>         조건 값이 값1일 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n>     case 값1:\n> \n>         조건 값이 값2일 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n>     ...\n> \n>     default:\n> \n>         조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n> }\n> ```\n\ndefault 절은 조건 값이 위에 나열된 어떠한 case 절에도 해당하지 않을 때만 실행됩니다.\n\n이 절은 반드시 존재해야 하는 것은 아니며 필요할 때만 선언할 수 있습니다.\n\n또한, default 절의 위치가 꼭 switch 문의 맨 마지막일 필요는 없습니다.\n\n> 예제\n> ``` cpp\n> switch (num)\n> \n> {\n> \n>     case 1:\n> \n>         cout << \"입력하신 수는 1입니다.\" << endl;\n> \n>         break;\n> \n>     case 2:\n> \n>         cout << \"입력하신 수는 2입니다.\" << endl;\n> \n>         break;\n> \n>     case 3:\n> \n>         cout << \"입력하신 수는 3입니다.\" << endl;\n> \n>         break;\n> \n>     case 4:\n> \n>         cout << \"입력하신 수는 4입니다.\" << endl;\n> \n>         break;\n> \n>     case 5:\n> \n>         cout << \"입력하신 수는 5입니다.\" << endl;\n> \n>         break;\n> \n>     default:\n> \n>         cout << \"1부터 5까지의 수만 입력해 주세요!\" << endl;\n> \n>         break;\n> \n> }\n> ```\n\n각 case 절 및 default 절은 반드시 break 키워드를 포함하고 있어야 합니다.\n\nbreak 키워드는 조건 값에 해당하는 case 절이나 default 절이 실행된 뒤에 전체 switch 문을 빠져나가게 해줍니다.\n\n만약에 break 키워드가 없다면, 조건에 해당하는 switch 문의 case 절 이후의 모든 case 절이 전부 실행될 것입니다.","excerpt":"조건문(Conditional Statements) 조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문입니다. C++에서 사용하는 대표적인 조건문의 형태는 다음과 같습니다. if 문 if / else 문 if / else if…","fields":{"slug":"/cpp07.md/"},"frontmatter":{"date":"Feb 29, 2020","title":"바닥에서 시작하는 C++ (7) - 조건문","tags":["C++"]}}},{"node":{"rawMarkdownBody":"\n## 연산자(Operator)\n\nC++은 여러 종류의 연산을 위해 다양한 연산자(operator)를 제공하고 있습니다. \n\n\n### 산술연산자(Arithmetic Operator)\n\n| 산술 연산자 |                                설명                                |\n|:-----------:|:------------------------------------------------------------------:|\n|      +      | 왼쪽의 피연산자에 오른쪽의 피연산자를 더함.                        |\n|      -      | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌.                        |\n|      *      | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함.                        |\n|      /      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔.                        |\n|      %      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함. |\n\n> 예제\n> ``` cpp\n> int num1 = 10;\n> \n> int num2 = 4;\n> \n>  \n> \n> cout << \"+ 연산자에 의한 결괏값은 \" << num1 + num2 << \"입니다.\" << endl;\n> // + 연산자에 의한 결괏값은 14입니다.\n> \n> cout << \"- 연산자에 의한 결괏값은 \" << num1 - num2 << \"입니다.\" << endl; \n> // - 연산자에 의한 결괏값은 6입니다.\n> \n> cout << \"* 연산자에 의한 결괏값은 \" << num1 * num2 << \"입니다.\" << endl; \n> // * 연산자에 의한 결괏값은 40입니다.\n> \n> cout << \"/ 연산자에 의한 결괏값은 \" << num1 / num2 << \"입니다.\" << endl; \n> // / 연산자에 의한 결괏값은 2입니다.\n> \n> cout << \"% 연산자에 의한 결괏값은 \" << num1 % num2 << \"입니다.\"; \n> // % 연산자에 의한 결괏값은 2입니다.\n> ```\n\n\n### 대입 연산자(Assignment Operator)\n\n| 대입 연산자 |                                         설명                                         |\n|:-----------:|:------------------------------------------------------------------------------------:|\n|      =      | 왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.                                        |\n|      +=     | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      -=     | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      *=     | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      /=     | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      %=     | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, </br>그 나머지를 왼쪽의 피연산자에 대입함. |\n\n\n> 예제\n> ``` cpp\n> int num1 = 8;\n> \n> int num2 = 8;\n> \n> int num3 = 8;\n> \n>  \n> \n> num1 = num1 + 5;\n> \n> num2 += 5;\n> \n> num3 =+ 5;\n> \n>  \n> \n> cout << \"- 연산자에 의한 결괏값은 \" << num1 << \"입니다.\" << endl;\n> // -  연산자에 의한 결괏값은 13입니다.\n> \n> cout << \"+= 연산자에 의한 결괏값은 \" << num2 << \"입니다.\" << endl;\n> // += 연산자에 의한 결괏값은 13입니다.\n> \n> cout << \"=+ 연산자에 의한 결괏값은 \" << num3 << \"입니다.\";\n> // =+ 연산자에 의한 결괏값은 5입니다.\n> \n> ```\n\n\n\n**주의**\n\n위의 예제에서 num =+ 5 연산은 단순히 숫자 5를 변수 num3에 대입하는 연산이 되었습니다. </br>이처럼 복합 대입 연산자에서 연산자의 순서는 매우 중요하므로 주의를 기울여야 합니다.\n\n### 논리 연산자(Logical Operator)\n\n| 논리 연산자 |                               설명                               |\n|:-----------:|:----------------------------------------------------------------:|\n|      &&     |         논리식이 모두 참이면 1을 반환함. (논리 AND 연산)         |\n|      \\|\\|     |     논리식 중에서 하나라도 참이면 1을 반환함. (논리 OR 연산)     |\n|      !      | 논리식의 결과가 참이면 0을, 거짓이면 1을 반환함. (논리 NOT 연산) |\n\n> 예제\n> ``` cpp\n> int num1 = 3;\n> \n> int num2 = -7;\n> \n> bool result1, result2;\n> \n>  \n> \n> result1 = (num1 > 0) && (num1 < 5);\n> \n> result2 = (num2 < 0) || (num2 > 10);\n> \n>  \n> \n> cout << \"&& 연산자에 의한 결괏값은 \" << result1 << \"입니다.\" << endl;\n> // && 연산자에 의한 결괏값은 1입니다.\n> \n> cout << \"|| 연산자에 의한 결괏값은 \" << result2 << \"입니다.\" << endl;\n> // || 연산자에 의한 결괏값은 1입니다.\n> \n> cout << \" ! 연산자에 의한 결괏값은 \" << !result2 << \"입니다.\" << endl;\n> // ! 연산자에 의한 결괏값은 0입니다.\n> ```\n\n### 삼항 연산자(Ternary Operator)\n\n> 문법\n> ``` cpp\n> 조건식 ? 반환값1(True) : 반환값2(False)\n> \n> ```\n\n물음표(?) 앞의 조건식에 따라 결괏값이 참(true)이면 반환값1을 반환하고, 결괏값이 거짓(false)이면 반환값2를 반환합니다.\n\n조건문과 같은 방식으로 쓰이며 이를 다음과 같이 조건문으로 바꾸어 쓸 수도 있지만, 조건문에 대한 자세한 내용은 후술하도록 하겠습니다.\n\n> ``` cpp\n> if (조건식)\n> \n> {\n>     반환값1(True)\n> }\n> \n> else\n> {\n>     반환값2(False)\n> }\n> ```","excerpt":"연산자(Operator) C++은 여러 종류의 연산을 위해 다양한 연산자(operator)를 제공하고 있습니다.  산술연산자(Arithmetic Operator…","fields":{"slug":"/cpp06.md/"},"frontmatter":{"date":"Feb 27, 2020","title":"바닥에서 시작하는 C++ (6) - 연산자(Operator)","tags":["C++"]}}},{"node":{"rawMarkdownBody":"\n## 상수\n\n상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미합니다.\n\n하지만 상수가 변수와 다른 점은 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다는 점입니다.\n\nC++에서 상수는 표현 방식에 따라 다음과 같이 나눌 수 있습니다.\n\n \n\n1. 리터럴 상수(literal constant)\n\n2. 심볼릭 상수(symbolic constant)\n\n## 리터럴 상수\n\n리터럴(Literal)은 변수에 넣는 변하지 않는 데이터를 말합니다.\n> ``` cpp\n> a = 5;\n> ```\n\n이 코드에서 5는 리터럴 상수입니다.\n\n리터럴 상수는 정수, 부동 소수점, 문자, 문자열, Boolean, 포인터 및 사용자가 정의한 리터럴로 분류 할 수 있습니다.\n\n### 정수 숫자\n> ``` cpp\n> 231\n>\n> 5542\n>\n> -43\n> ```\n\n정숫값을 식별하는 숫자 상수입니다. 인용 부호나 다른 특수 문자로 묶여 있지 않습니다.\n\n231은 문자 그대로 항상 231이라는 수 자체를 나타냅니다.\n\n\n### 부동 소수점 숫자\n\n소수점과 지수로 실제 값을 표현합니다.\n\n> ``` cpp\n> 3.14159    // 3.14159\n>\n> 6.02e23    // 6.02 x 10^23\n>\n> 1.6e-19    // 1.6 x 10^-19\n>\n> 3.0        // 3.0\n> ```\n\n### 문자 및 문자열 리터럴\n\n문자 및 문자열 리터럴은 따옴표로 묶습니다.\n\n> ``` cpp\n> 'z'\n> \n> 'q'\n> \n> \"Hello world\"\n> \n> \"KHU Software Convergence\"\n> \n> ```\n\n처음 두 표현식은 단일 문자 리터럴을 나타내고, 다음 두 표현식은 여러 문자로 구성된 문자열 리터럴을 나타냅니다.\n\n단일 문자를 나타내려면 작은 따옴표(`'`)로 묶고 문자열을 나타내려면 큰따옴표(`\"`)로 문자를 묶습니다.\n\n### 그 외의 리터럴\n\nC++에는 세 가지 키워드 리터럴(true, false, nullptr)이 있습니다.\n\n- bool 유형의 변수에는 true와 false만 사용이 가능합니다.\n- nullptr은 null 포인터 값 입니다.\n\n## 상수 표현식\n\n다음처럼 `const`를 사용하여 상수를 정의할 수도 있습니다.\n\n``` cpp\nconst double pi = 3.1415926;\n\nconst char tab = '\\t';\n```\n\n## 전처리기 정의 (#define)\n\n> ``` cpp\n> #define PI 3.14159\n> \n> #define NEWLINE '\\n'\n> ```\n\n**\\#define은 전 처리기 지시문이며, 끝에 세미콜론(`;`)이 필요하지 않습니다.**","excerpt":"상수 상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미합니다. 하지만 상수가 변수와 다른 점은 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다는 점입니다. C…","fields":{"slug":"/cpp05.md/"},"frontmatter":{"date":"Feb 23, 2020","title":"바닥부터 시작하는 C++ (5) - 상수","tags":["C++"]}}},{"node":{"rawMarkdownBody":"\n## 변수(Variable)\n\n변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미합니다.\n\n즉, 변수란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하며, 이렇게 저장된 값은 변경될 수 있습니다.\n\n \n\nC++에서 숫자 표현에 관련된 변수는 정수형 변수와 실수형 변수로 구분할 수 있습니다.\n\n또다시 정수형 변수는 char형, int형, long형, long long형 변수로, 실수형 변수는 float형, double형 변수로 구분됩니다.\n\n## 변수의 이름 생성 규칙\n\nC++에서는 변수의 이름을 비교적 자유롭게 지을 수 있습니다.\n\n변수의 이름은 해당 변수에 저장될 데이터의 의미를 잘 나타내도록 짓는 것이 좋습니다.\n\n \n\nC++에서 변수의 이름을 생성할 때 반드시 지켜야 하는 규칙은 다음과 같습니다.\n\n \n1. 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성됩니다.\n\n2. 변수의 이름은 숫자로 시작될 수 없습니다.\n\n3. 변수의 이름 사이에는 공백을 포함할 수 없습니다.\n\n4. 변수의 이름으로 C++에서 미리 정의된 키워드(keyword)는 사용할 수 없습니다.\n\n5. 변수 이름의 길이에는 제한이 없습니다.\n\n**C++은 변수의 이름에 대소문자를 구분합니다!**\n\n## 변수와 메모리 주소\n\n변수는 기본적으로 메모리의 주소(address)를 기억하는 역할을 합니다.\n\n메모리 주소란 물리적인 메모리 공간을 서로 구분하기 위해 사용되는 일종의 식별자입니다.\n\n즉, 메모리 주소란 메모리 공간에서의 정확한 위치를 식별하기 위한 고유 주소를 의미합니다.\n\n \n\n변수를 참조할 때는 메모리의 주소를 참조하는 것이 아닌, 해당 주소에 저장된 데이터를 참조하게 됩니다.\n\n따라서 변수는 데이터가 저장된 메모리의 주소뿐만 아니라, 저장된 데이터의 길이와 형태에 관한 정보도 같이 기억해야 합니다.\n\n \n\n다음 그림은 메모리상에 변수가 어떤 식으로 저장되는지를 보여줍니다.\n\n![변수 저장 방법](1.png)\n\n이 내용은 포인터의 개념을 이해하기 위해 필요한 개념이므로 익혀두는 것이 좋습니다.\n\n## 변수의 선언\n\nC++에서는 변수를 사용하기 전에 반드시 먼저 해당 변수를 저장하기 위한 메모리 공간을 할당받아야 합니다.\n\n이렇게 해당 변수만을 위한 메모리 공간을 할당받는 행위를 변수의 선언이라고 부릅니다.\n\n \n\nC++에서 변수를 선언하는 방법에는 다음과 같이 두 가지 방법이 있습니다.\n\n \n\n1. 변수의 선언만 하는 방법\n\n2. 변수의 선언과 동시에 초기화하는 방법\n\n### 변수의 선언만 하는 방법\n\n이 방법은 먼저 변수를 선언하여 메모리 공간을 할당받고, 나중에 변수를 초기화하는 방법입니다.\n\n하지만 이렇게 선언만 된 변수는 초기화하지 않았기 때문에 해당 메모리 공간에는 알 수 없는 쓰레깃값만이 들어가 있습니다.\n\n따라서 초기화하지 않은 변수는 절대로 사용해서는 안 됩니다.\n> 문법\n> ``` cpp\n> 타입 변수이름;\n> ```\n\n다음의 예제와 같이 먼저 변수를 선언해둔 뒤 나중에 초기화해줄 수 있습니다.\n\n> 예제\n> ``` cpp\n> int num;\n> \n> ...\n> \n> num = 20;\n> ```\n\n\n### 변수의 선언과 동시에 초기화하는 방법\n\nC++에서는 변수의 선언과 동시에 그 값을 초기화할 수 있습니다.\n\n또한, 선언하고자 하는 변수들의 타입이 같다면 이를 동시에 선언할 수 있습니다.\n\n> 문법\n> ``` cpp\n> \n> 타입 변수이름[, 변수이름];\n> \n> 타입 변수이름 = 초깃값[, 변수이름 = 초깃값];\n> \n> ```\n\n> 예제\n> ``` cpp\n> int num1, num2;\n> \n> double num3 = 1.23, num4 = 4.56;\n> ```\n","excerpt":"변수(Variable) 변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미합니다. 즉, 변수란 데이터(data…","fields":{"slug":"/cpp04.md/"},"frontmatter":{"date":"Feb 20, 2020","title":"바닥부터 시작하는 C++ (4) - 변수","tags":["C++"]}}},{"node":{"rawMarkdownBody":"\n## iostream(Input/Output Stream)\n\n사용자가 프로그램과 대화하기 위해서는 사용자와 프로그램 사이의 입출력을 담당하는 수단이 필요합니다.\n\nC++의 모든 것은 객체로 표현되므로, 입출력을 담당하는 수단 또한 C언어의 함수와는 달리 모두 객체입니다.\n\n \n\nC언어의 printf() 함수나 scanf() 함수처럼 C++에서도 **iostream 헤더 파일에 표준 입출력 클래스를 정의**하고 있습니다.\n\nC++에서는 **cout 객체로 출력** 작업을, **cin 객체로 입력** 작업을 수행하고 있습니다.\n\n \n\n또한, C++에서는 기존의 C언어 스타일처럼 printf() 함수나 scanf() 함수로도 입출력 작업을 수행할 수 있습니다.\n\n## cout 객체\n\ncout 객체는 다양한 데이터를 출력하는 데 사용되는 C++에서 미리 정의된 출력 스트림을 나타내는 객체입니다.\n\ncout 객체를 사용하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> std::cout << 출력할 데이터;\n> ```\n\n삽입 연산자(<<)는 오른쪽에 위치한 출력할 데이터를 출력 스트림에 삽입합니다.\n\n이렇게 출력 스트림에 삽입된 데이터는 스트림을 통해 출력 장치로 전달되어 출력됩니다.\n\n``` cpp\ncout << \"Hello World!\"; // Hello World!\n```\n\n## cin 객체\n\ncin 객체는 다양한 데이터를 입력받는 데 사용되는 C++에서 미리 정의된 입력 스트림을 나타내는 객체입니다.\n\ncin 객체를 사용하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> std::cin >> 저장할 변수;\n> ```\n추출 연산자(>>)를 통해 사용자가 입력한 데이터를 입력 스트림에서 추출하여, 오른쪽에 위치한 변수에 저장합니다.\n\n이때 cin 객체는 자동으로 사용자가 입력한 데이터를 오른쪽에 위치한 변수의 타입과 동일하게 변환시켜 줍니다.\n\n**주의 : cout과 cin의 화살표 방향이 서로 다릅니다!**\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> using namespace std;\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     int age;\n> \n>  \n> \n>     cout << \"나이를 입력해 주세요 : \";\n> \n>     cin >> age;\n> \n>  \n> \n>     cout << age << \"살 입니다.\" << endl;\n> \n>     return 0;\n> \n> }\n> ```\n\n위의 예제에서 여러분이 입력한 데이터는 자동으로 정수를 저장할 때 사용하는 타입으로 변환될 것입니다.\n\n만약에 문자열을 입력하면 cin 객체는 변수 age에 숫자가 아니라는 의미인 0을 전달할 것입니다.\n\n## C언어 표준 입출력 함수와의 차이점\n\nC언어 표준 입출력 함수인 printf() 함수나 scanf() 함수와 C++ 표준 입출력 객체와의 차이점은 다음과 같습니다.\n\n \n\n1. 삽입 연산자(<<)와 추출 연산자(>>)가 데이터의 흐름을 나타내므로 좀 더 직관적입니다.\n\n2. C++ 표준 입출력 객체는 입출력 데이터의 타입을 자동으로 변환시켜주므로 더욱 편리하고 안전합니다.\n\n","excerpt":"iostream(Input/Output Stream) 사용자가 프로그램과 대화하기 위해서는 사용자와 프로그램 사이의 입출력을 담당하는 수단이 필요합니다. C++의 모든 것은 객체로 표현되므로, 입출력을 담당하는 수단 또한 C…","fields":{"slug":"/cpp03.md/"},"frontmatter":{"date":"Feb 18, 2020","title":"바닥부터 시작하는 C++ (3) - iostream","tags":["C++"]}}},{"node":{"rawMarkdownBody":"\n## 네임스페이스(Namespace)\n\n네임스페이스란 이름이 기억되는 영역을 뜻하며, 이름이 소속된 공간을 의미합니다.\n\n네임스페이스는 C++ 프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해 주는 방법을 제공합니다.\n\n이러한 네임스페이스는 C언어에는 없는 C++ 만의 새로운 기능입니다.\n\n \n\nC++ 프로그램의 표준 구성 요소인 클래스, 함수, 변수 등은 std라는 이름 공간에 저장되어 있습니다.\n\n따라서 C++ 프로그램에서 표준 헤더 파일인 iostream 내의 정의를 사용하려면 다음과 같이 사용해야 합니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     std::cout << TEXT;\n> \n>     return 0;\n> \n> }\n> ```\n\n위의 예제처럼 std라는 네임스페이스에 있는 정의를 사용하려면, std:: 접두어를 붙여 해당 정의가 std라는 네임스페이스에 있다는 것을 컴파일러에 알려줘야 합니다.\n\n \n\n이러한 네임스페이스에 속한 정의를 간단하게 사용하려면 다음과 같은 명령문을 추가하면 됩니다.\n\n> ``` cpp\n> using namespace std; // std라는 네임스페이스에 속한 정의들은 네임스페이스 이름을 붙이지 않아도 사용할 수 있음.\n> ```\n\n다음 예제는 앞서 살펴본 예제와 정확히 같은 동작을 수행합니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n> using namespace std;\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     cout << TEXT;\n> \n>     return 0;\n> \n> }\n> ```\n\n## 주석\n\n주석이란 코드에 대한 이해를 돕는 설명을 적거나 디버깅을 위해 작성하는 일종의 메모입니다.\n\nC++ 컴파일러는 주석은 무시하고 컴파일하므로, 실행 파일에서는 이러한 주석을 확인할 수 없습니다.\n\n \n\nC++에서 주석을 작성하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> // 한 줄 주석\n> \n> /*\n> \n> 여러 줄 주석\n> \n> */\n> ```\n\nC++에서는 여러 줄 주석 안에 또 다른 한 줄 주석을 삽입할 수 있습니다.\n하지만 여러 줄 주석 안에 또 다른 여러 줄 주석은 중첩해서 삽입할 수는 없습니다.\n\n> ``` cpp\n> /*\n> \n> 여러 줄 주석\n> \n> //한 줄 주석 삽입 가능!\n>\n> */\n>\n> \n> /*\n> \n> 여러 줄 주석\n> \n> /*여러 줄 주석 삽입 불가*/\n>\n> */\n>\n> ```\n\n위의 예제 마지막 줄 */는 주석으로 처리되지 않은 것을 확인할 수 있습니다.","excerpt":"네임스페이스(Namespace) 네임스페이스란 이름이 기억되는 영역을 뜻하며, 이름이 소속된 공간을 의미합니다. 네임스페이스는 C++ 프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해 주는 방법을 제공합니다. 이러한 네임스페이스는 C…","fields":{"slug":"/cpp02.md/"},"frontmatter":{"date":"Feb 16, 2020","title":"바닥부터 시작하는 C++ (2) - 네임스페이스, 주석","tags":["C++"]}}},{"node":{"rawMarkdownBody":"\n## C++의 특징\n\nC++이 프로그래밍 언어로써 가지는 특징은 다음과 같습니다.\n\n \n\n1. C++은 절차 지향적이며 구조적 프로그래밍 언어입니다.\n\n2. C++은 객체 지향 프로그래밍 언어입니다.\n\n3. C++은 일반화 프로그래밍 언어입니다.\n\n \n\n이처럼 C++은 세 가지 프로그래밍 방식을 모두 지원하는 언어이며, 따라서 다양한 방식으로 프로그램을 작성할 수 있습니다.\n\n또한, 다양한 시스템에서의 프로그래밍을 지원하는 유용하고도 강력한 클래스 라이브러리들이 아주 많이 제공됩니다.\n\n\n## 실행 파일 생성 과정\n\n![실행 파일 생성 과정](1.png)\n\n1. 소스 파일(source file)의 작성\n\n2. 선행처리기(preprocessor)에 의한 선행처리\n\n3. 컴파일러(compiler)에 의한 컴파일\n\n4. 링커(linker)에 의한 링크\n\n5. 실행 파일(executable file)의 생성\n\n## 기본 구조\n\n간단한 C++ 프로그램의 기본 구조는 다음과 같습니다.\n\n언제나 다음과 같이 구성되는 것은 아니지만 많은 C++ 프로그램이 이와 비슷한 형태로 구성됩니다.\n\n> 문법\n> ``` cpp\n> #include 문\n> \n> #define 문\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     명령문;\n> \n>     return 문;\n> \n> }\n> ```\n\n간단한 텍스트를 출력하는 예제는 다음과 같습니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     std::cout << TEXT; // Welcome to C++ Programming!!\n> \n>     return 0;\n> \n> }\n> ```\n\n### main() 함수\n\nC++ 프로그램은 가장 먼저 main() 함수를 찾고, 그곳에서부터 실행을 시작합니다.\n\n따라서 모든 C++ 프로그램은 반드시 하나의 main() 함수를 가지고 있어야 합니다.\n\n만약 main() 함수를 발견하지 못하면 C++ 컴파일러는 오류를 발생시킬 것입니다.\n\n### 명령문(Statement)\n\nC++ 프로그램의 동작을 명시하고, 이러한 동작을 컴퓨터에 알려주는 데 사용되는 문장을 명령문(statement)이라고 합니다.\n\n이러한 C++의 모든 명령문은 반드시 세미콜론(;)으로 끝나야 합니다.\n\n> ``` cpp\n> std::cout << \"C++ 프로그래밍\"; // 정상적으로 출력됨.\n> \n> std::cout << \"C++ 프로그래밍\"  // 오류가 발생함.\n> \n> ```\n\n### 반환문(Return)\n\n반환문은 함수의 종료를 의미하며, 함수를 호출한 곳으로 결괏값을 반환하는 역할을 합니다.\n\n특히 main() 함수가 반환되면, 프로그램 전체가 종료됩니다.\n\n### 선행처리문(Preprocess)\n\n\\#include 문과 #define 문은 모두 선행처리기에 의해 처리되는 선행처리문입니다.\n\n \n\n\\#include 문은 외부에 선언된 함수나 상수 등을 사용하기 위해서 헤더 파일의 내용을 현재 파일에 포함할 때 사용합니다.\n\nC언어에서는 헤더 파일에 .h 확장자를 사용했지만, C++에서는 헤더 파일의 확장자를 사용하지 않기로 합니다.\n\n따라서 기존 C언어 헤더 파일들의 이름 앞에 c를 추가하여 C++ 스타일의 헤더 파일로 변환하기도 합니다.\n> ``` cpp\n> #include <math.h> // C, C++ 모두 허용\n> \n> #include <cmath>  // C++에서만 허용\n> ```\n\n물론 원칙은 위와 같이 바뀌었지만 C++ 프로그램에서는 기존의 C언어 스타일로도 헤더 파일을 사용할 수 있습니다.\n\n\\#define 문은 함수나 상수를 단순화해주는 매크로를 정의할 때 사용합니다.","excerpt":"C++의 특징 C++이 프로그래밍 언어로써 가지는 특징은 다음과 같습니다. C++은 절차 지향적이며 구조적 프로그래밍 언어입니다. C++은 객체 지향 프로그래밍 언어입니다. C++은 일반화 프로그래밍 언어입니다. 이처럼 C…","fields":{"slug":"/cpp01.md/"},"frontmatter":{"date":"Feb 14, 2020","title":"바닥부터 시작하는 C++ (1) - 기본 특징","tags":["C++"]}}}]}},"pageContext":{}}}