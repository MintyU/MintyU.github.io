{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## 문제\n\n닭이 길을 건너간 이유는 과학적으로 깊게 연구가 되어 있지만, 의외로 소가 길을 건너간 이유는 거의 연구된 적이 없다. 이 주제에 관심을 가지고 있었던 농부 존은 한 대학으로부터 소가 길을 건너는 이유에 대한 연구 제의를 받게 되었다.\n\n존이 할 일은 소가 길을 건너는 것을 관찰하는 것이다. 존은 소의 위치를 N번 관찰하는데, 각 관찰은 소의 번호와 소의 위치 하나씩으로 이루어져 있다. 존은 소를 10마리 가지고 있으므로 소의 번호는 1 이상 10 이하의 정수고, 소의 위치는 길의 왼쪽과 오른쪽을 의미하는 0과 1 중 하나다.\n\n이 관찰 기록을 가지고 소가 최소 몇 번 길을 건넜는지 알아보자. 즉 같은 번호의 소가 위치를 바꾼 것이 몇 번인지 세면 된다.\n\n## 입력\n\n첫 줄에 관찰 횟수 N이 주어진다. N은 100 이하의 양의 정수이다. 다음 N줄에는 한 줄에 하나씩 관찰 결과가 주어진다. 관찰 결과는 소의 번호와 위치(0 또는 1)로 이루어져 있다.\n\n## 출력\n\n첫 줄에 소가 길을 건너간 최소 횟수를 출력한다.\n\n#### <예제 입력 1>\n\n```\n8\n3 1\n3 0\n6 0\n2 1\n4 1\n3 0\n4 0\n3 1\n```\n\n##### <예제 출력 1>\n\n`3`\n\n## 풀이\n\n문제의 핵심은 다음과 같다.\n\n1. 소의 위치는 0과 1로 표현된다.\n\n2. 위치가 0에서 1, 또는 1에서 0으로 바뀐 경우가 길을 건넌 경우에 해당한다.\n\n문제의 입력 형식과 비교해 보았을 때, **소의 위치가 처음 초기화되는 경우**에는 길을 건넌 것으로 카운트하지 않으며, **소의 위치가 그대로인 경우**에도 카운트하지 않습니다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n\n    int n = 0;\n\n    int cow[11] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n    // 소의 초기 위치를 -1로 설정(default)\n\n    cin >> n;\n\n    int count = 0;\n\n    for (int i = 1; i <= n; i++)\n    {\n        int cownum, pos;\n\n        cin >> cownum >> pos;  // test case 입력\n\n        if (cow[cownum] == -1) { // 소의 위치가 default인 경우\n\n            cow[cownum] = pos; // 입력값으로 초기화\n\n        }\n\n        else if (cow[cownum] != pos && cow[cownum] != -1)\n        // 소의 위치가 -1이 아닌 다른 값으로 초기화되어있으며, 이미 초기화된 값과 다른 위치값을 입력받은 경우\n\n        {\n            cow[cownum] = pos; // 입력값으로 위치 재설정\n\n            count += 1; // 이동 횟수 증가!\n        }\n\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n```\n\n위 코드와 같이 **소의 위치가 처음 초기화되는 경우**와 **소의 위치가 그대로인 경우**만 체크해주더라도 쉽게 풀 수 있는 문제였습니다.\n","excerpt":"…","fields":{"slug":"/BOJ14467/"},"frontmatter":{"date":"Jul 04, 2020","title":"백준 [14467] - 소가 길을 건너간 이유 1","tags":["백준알고리즘(C++)"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## VSCode 괄호 Tab키로 나가기\n\nVSCode에는 기본적으로 괄호를 한 쪽`\" ( \"` 입력하면 나머지 한 쪽도 자동 완성되어 `\" ( ) \"`이렇게 입력됩니다.\n\n이 자동완성 기능을 끄는 방법도 있겠지만, 어차피 괄호를 열었다면 닫는 버튼을 한번 더 입력해야하는 것은 마찬가지입니다.\n\n다른 IDE나 Editor에서는 `Tab`버튼을 통해 괄호나 따옴표 밖으로 나가는 것을 지원하는것 같았는데 VSCode 자체에서는 그 기능을 찾을 수가 없었습니다.\n\n그래서 더 쉽게 괄호를 탈출하는 방법은 없을까 해서 찾던 중, [깃허브](https://github.com/microsoft/vscode/issues/22864)에서 그 해결 방법을 찾을 수 있었습니다.\n\n바로 **\"TabOut\"**이라는 Extension입니다.\n\n### 설치\n\n![](1.png)\n\n좌측 메뉴에서 Extension 탭을 선택한 후, 마켓플레이스에서 `\"TabOut\"`을 검색한 후 설치해줍니다.\n\n![](2.png)\n\n설치가 완료되었다면 탭을 통해 쌍(Pair)이 있는 괄호나 따옴표의 한 단계 밖으로 나갈 수 있습니다.\n","excerpt":"VSCode 괄호 Tab키로 나가기 VSCode…","fields":{"slug":"/TabOut/"},"frontmatter":{"date":"May 03, 2020","title":"VSCode 괄호, 따옴표 Tab으로 나가기 [VSCode]","tags":["VSCode"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## VSCode Format?\n\nVSCode에는 지정된 형식으로 코드를 깔끔하고 예쁘게 정리해줄 수 있는 기능이 존재합니다.\n\n그 기능은 바로 Format 기능인데, VSCode에서 별다른 설정을 만지지 않았다면 `⌥ + ⇧ + F`로 실행할 수 있습니다. (Windows 운영체제의 경우 `Alt + Shift + F`)\n\n아무생각없이 코딩을 하다 보면, 다음과 같이 가독성이 떨어질 수 있습니다.\n\n![](1.png)\n\n중괄호가 시작하는 위치도 일정하지 않고, 들여쓰기도 일관적이지 않습니다.\n\n뿐만 아니라, 연산자와 변수가 붙어있고 배열 안의 항목들도 붙어있어 가독성이 매우 떨어집니다.\n\n(괄호에 적용된 색은 `Bracket Pair Colorizer`라는 Extention이며, 괄호의 쌍을 찾기 쉽게 색을 지정해준다. Extension에 관한 내용은 추후에 따로 포스트할 예정!)\n\n이럴 떄, 앞에서 설명했던 Format 기능을 실행하면 다음과 같이 코드가 변하게 됩니다.\n\n![](2.png)\n\n중괄호 시작 위치와 들여쓰기를 일정하게 맞춰주며, 띄어쓰기를 자동으로 적절한 위치에 삽입해줘서 가독성을 좋게 해줍니다.\n\n하지만, 아무 설정도 하지 않았다면 배열의 원소들을 둘러싸고 있는 중괄호 사이는 떨어지지 않습니다.\n\n중괄호와 원소 사이의 간격을 띄우게 되면 원소를 더 명확하게 구분할 수 있으며 가독성 향상에 도움을 주기 때문에 따로 설정해주는 것을 추천해 드립니다.\n\n설정을 진행하게 되면 다음과 같은 변화가 있습니다.\n\n```cpp\narr[3] = {1, 2, 3};\n// From this...\n\narr[3] = { 1, 2, 3 };\n// To this!\n```\n\n설정 방법은 아래와 같습니다.\n\n### 배열 원소와 중괄호 사이 띄어쓰기 설정\n\n우선, 설정을 위해서는 `⌘ + ,`를 통해 설정 탭을 열어줍니다. (Windows의 경우 `Ctrl + ,`)\n\n그리고 `clang_format`을 검색해주면 다음과 같은 항목들을 볼 수 있습니다.\n\n![](3.png)\n\n가장 위에 나오는 `Clang_format_fallback Style`항목은 따로 설정해주지 않았다면 지금 스크린샷에 나온것과 달리 `Visual Studio`라고 적혀있을 것입니다.\n\n설명에 쓰여 있는 것처럼 `Visual Studio`, `LLVM`, `Chromium`, `Google` 등의 스타일 세트를 따로 지정해줄 수도 있고,\n\n`{key: value ...}`와 같은 형태로 직접 세부 스타일 하나하나 따로 지정해줄 수도 있습니다.\n\n`Visual Studio` 스타일을 `{key: value ...}`형태로 쓰면 다음과 같습니다.\n\n```\n{ BasedOnStyle: LLVM,\nUseTab: Never,\nIndentWidth: 4,\nTabWidth: 4,\nBreakBeforeBraces: Allman,\nAllowShortIfStatementsOnASingleLine: false,\nIndentCaseLabels: false,\nColumnLimit: 0,\nAccessModifierOffset: -4 }\n```\n\n위에서 제일 마지막에 `Cpp11BracedListStyle`이라는 하나의 항목을 더 추가해주고 false로 설정하면 끝입니다.\n\n```\n{ BasedOnStyle: LLVM,\nUseTab: Never,\nIndentWidth: 4,\nTabWidth: 4,\nBreakBeforeBraces: Allman,\nAllowShortIfStatementsOnASingleLine: false,\nIndentCaseLabels: false,\nColumnLimit: 0,\nAccessModifierOffset: -4,\nCpp11BracedListStyle: false }\n```\n\n이 항목을 그대로 복사해서 `Clang_format_fallback Style` 설정의 입력란에 넣으시면 설정이 완료됩니다.\n\n### 저장하면서 형식 지정해주기(Format On Save)\n\n단축키가 상당히 불편하고 외우기 어렵다보니, 저장과 동시에 Formatting을 해주는 기능을 이용하는 것이 훨씬 간편합니다.\n\n이 설정 방식은 아까와 같이 우선 `⌘ + ,`를 통해 설정 탭을 열어줍니다. (Windows의 경우 `Ctrl + ,`)\n\n그리고 `format on save`를 검색해주면 다음과 같은 설정이 있습니다.\n\n![](4.png)\n\n체크박스에 체크를 해주시면 앞으로는 저장과 동시에 자동으로 Format 기능을 실행할 수 있습니다!\n","excerpt":"VSCode Format? VSCode에는 지정된 형식으로 코드를 깔끔하고 예쁘게 정리해줄 수 있는 기능이 존재합니다. 그 기능은 바로 Format 기능인데, VSCode에서 별다른 설정을 만지지 않았다면 로 실행할 수 있습니다. (Windows…","fields":{"slug":"/Format/"},"frontmatter":{"date":"Apr 26, 2020","title":"VSCode 저장 시 자동 format 지정 [VSCode]","tags":["VSCode"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## fstream\n\nC++에서 입력과 출력을 관리하기 위해 사용했던 `<iostream>`헤더파일과 마찬가지로, 파일을 통한 데이터 입출력을 관리하는 헤더 파일은 `<fstream>`으로 정의되어 있습니다.\n\n또한, `<iostream>`에서 입력은 istream, 출력은 ostream이라는 Class를 통해 정의된 것처럼 `<fstream>`에서 파일 열기(read)는 ifstream, 파일 쓰기(write)는 ofstream으로 Class가 정의되어 있습니다. 'i'와 'o'는 각각 in과 out을 의미합니다.\n\n`<iostream>`헤더와 `<fstream>`헤더에서는 공통적으로 데이터의 이동 방향을 철저히 '실행 파일'기준으로 처리합니다.\n\n예를 들자면, `<iostream>`을 통해 실행 파일에 데이터를 '입력'하는 것이 istream이며 '출력'하는 것이 ostream이지만\n\n실행 파일에서 `<fstream>`을 통해 txt파일에 데이터를 '입력'하는것은 ofstream이며, 파일로부터 데이터를 불러오는 것은 ifstream입니다.\n\n사실 이렇게 해석하면 굉장히 혼란의 여지가 많습니다.\n\n실행 파일에서 `<fstream>`을 통해 txt파일로 데이터를 '출력'(내보내는 것)이 ofstream이며, txt파일로부터 데이터를 '입력'받는것을 ifstream이라고 해석하는 것이 자연스럽습니다.\n\n### ifstream\n\n우선 텍스트파일로부터 데이터를 읽어오는 ifstream에 대해 먼저 알아보겠습니다.\n\nifstream 객체를 하나 생성하고, 읽어올 파일을 선택해야 합니다.\n\n이 방법에는 두 가지 방법이 있습니다.\n\n첫째는 선언과 동시에 파일을 지정해주는 방법입니다.\n\n```cpp\nifstream fin(\"text.txt\");\n```\n\n둘째는 선언 후 파일을 지정해주는 방법입니다.\n\n```cpp\nifstream fin;\nfin.open(\"text.txt\");\n```\n\n위의 두 예제 모두 `fin`이라는 이름의 객체가 `\"text.txt\"`파일을 열어놓은 상태입니다.\n\n파일이 제대로 열렸는지를 확인하는 방법은 다음과 같습니다(ifstream 객체의 이름을 fin으로 설정했다는 가정 하에 진행합니다.)\n\n```cpp\nif (!fin)\n{\n    cout << \"Error, no such file exists\" << endl;\n    exit(100);\n}\n```\n\n위 코드는 열려고 하는 파일이 존재하지 않을 때, 에러 메시지를 출력하며 프로그램을 종료합니다.\n\n파일이 잘 열렸다면, 이제 파일 안에 있는 데이터를 가져올 차례입니다.\n\n텍스트 파일의 내용은 다음과 같다고 가정하겠습니다.\n\n> text.txt\n>\n> ```\n> 1\n> 2\n> 3\n> 4\n> 5\n> ```\n\n이제 `<iostream>`헤더파일의 `cin`의 사용법과 비슷하게 정의해놓은 `fin`을 사용하면 됩니다.\n\n다음은 `text.txt`의 내용을 읽어와서 출력하는 예제입니다.\n\n```cpp\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    ifstream fin(\"text.txt\"); // fin 객체 생성(cin 처럼 이용!)\n    if (!fin)\n    {\n        cout << \"Error, no such file exists\" << endl;\n        exit(100);\n    } // 파일 열림 확인\n\n    int i;\n    while (true)\n    {\n        fin >> i;\n        if (fin.eof()) // 읽어올 파일의 끝이면(End Of File)\n        {\n            break; // 읽기를 마치고 반복문을 나간다.\n        }\n        cout << i << endl;\n    }\n\n    fin.close(); // 파일 닫기\n\n    return 0;\n}\n```\n\nmain함수 안의 반복문을 통해 파일에서 한 단어씩 읽어온 후, 출력하는 예제입니다.\n\n`fin.eof()`는 `fin`을 통해서 읽어온 파일의 끝에 도달하면, True를 리턴합니다.\n\n이를 통해 조건문으로 파일의 끝까지 읽었을 때 반복문을 탈출하도록 할 수 있습니다.\n\n파일을 열고 잘 출력까지 마무리했다면, 파일을 닫아줄 차례입니다.\n\n예제의 `fin.close()`가 바로 그 역할입니다.\n\n사용 후 닫지 않는다면 열려있는동안 파일이 Lock되거나 다른 사람이 이용하지 못하게 될 수 있으므로, 사용 후에는 꼭 닫아주도록 합시다.\n\n#### 한 줄씩 입력을 받고 싶다면?\n\nifstream도 cin과 마찬가지로 화이트스페이스(whitespace)를 기준으로 입력을 구분합니다.\n\n따라서, 스페이스바를 통한 공백이나 줄바꿈을 통해 입력을 구분하게 됩니다.\n\n하지만, 단어가 아닌 문장으로, 띄어쓰기에 상관없이 한 줄씩 입력을 받고 싶다면 `std::getline(입력스트림 객체, 문자열 변수)`를 이용하면 됩니다.\n\n> ```\n> lorem.txt\n>\n> Lorem ipsum dolor sit amet,\n> consectetur adipiscing elit,\n> sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n> ```\n\n위와 같은 텍스트가 있다고 가정한 후, 한 줄씩 읽어와서 출력해주는 예제입니다.\n\n```cpp\n#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    ifstream fin(\"lorem.txt\"); // fin 객체 생성(cin 처럼 이용!)\n    if (!fin)\n    {\n        cout << \"Error, no such file exists\" << endl;\n        exit(100);\n    } // 파일 열림 확인\n\n    string str;\n    while (getline(fin, str)) // 파일이 끝날때까지 한 줄씩 읽어오기\n    {\n        cout << str << endl;\n    }\n\n    fin.close(); // 파일 닫기\n\n    return 0;\n}\n```\n\n### ofstream\n\nofstream은 데이터를 외부 파일로 저장하는 역할을 합니다.\n\nifstream과 마찬가지로, ofstream 객체를 만들고 데이터를 내보낼 파일 이름을 지정해줍니다.\n\n```cpp\nofstream fout(\"result.txt\");\n// 선언과 동시에 파일 이름 지정\n\nofstream fout;\nfout.open(\"result.txt\");\n// 선언 후 파일 이름 지정\n```\n\n이렇게 선언한 후, 앞에서 fin을 cin처럼 사용한것과 같이 fout을 cout처럼 사용해주면 됩니다.\n\nofstream에서는 지정해준 파일의 이름이 없더라도 자동으로 생성해주므로 굳이 파일이 없는 경우 오류를 출력할 필요가 없습니다.\n\n또한, 이미 내용이 저장되어 있는 파일을 지정하고 데이터를 저장해주었을 경우 내용을 덮어쓰게 됩니다.\n\n**즉, 이미 저장되어있던 내용은 삭제되고, 새로운 내용이 저장됩니다.**\n\n다음은 ofstream을 통해 `result.txt`에 1부터 5까지 줄을 바꾸어 하나씩 저장하는 예제입니다.\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main()\n{\n\tofstream fout(\"result.txt\");\n\n    for(int i = 1; i <= 5; i++)\n    {\n        fout << i << endl;\n    }\n\treturn 0;\n    fout.close();\n}\n```\n\n코드를 실행하면 실행한 디렉토리 안에 다음과 같은 텍스트 파일이 생성됩니다.\n\n> ```\n> result.txt\n>\n> 1\n> 2\n> 3\n> 4\n> 5\n>\n> ```\n\n여기까지 C++로 외부 파일과 입출력을 통해 상호작용하는 방법에 대해 알아보았습니다.\n\n아마 다른 언어로 이미 파일 입출력을 학습했던 경험이 있다면 크게 어렵게 느껴지지는 않을 것이라 예상됩니다.\n\n(파이썬에서의 파일 입출력 방식과 굉장히 비슷하다고 느꼈습니다.)\n","excerpt":"fstream C++에서 입력과 출력을 관리하기 위해 사용했던 헤더파일과 마찬가지로, 파일을 통한 데이터 입출력을 관리하는 헤더 파일은 으로 정의되어 있습니다. 또한, 에서 입력은 istream, 출력은 ostream이라는 Class…","fields":{"slug":"/cpp12/"},"frontmatter":{"date":"Apr 07, 2020","title":"바닥에서 시작하는 C++ (12) - 파일 입출력","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## C++의 문자열?\n\nC++은 문자열을 쉽게 다룰 수 있는 String Class를 제공합니다.\n\nC++에서 String Class를 사용하기 위해서는 String 헤더 파일을 포함해야 합니다.\n\n```cpp\n#include <string>\n```\n\n또한, String Class는 std namespace에 속해 있으므로 `using namespace std;`를 사용하거나 직접 `std::string`을 통해 사용해야 합니다.\n\nC++에서 String도 다른 일반적인 변수들처럼 사용됩니다.\n\n다른 변수들과 마찬가지로 선언과 동시에 초기화를 해줄 수도 있고, 선언 후 나중에 초기화를 해줄 수도 있습니다.\n\n다음 예제는 `using namespace std;`가 작성되어있다는 전제 하에 진행됩니다.\n\n```cpp\nstring str = \"Hello!\";\n// 선언과 동시에 초기화\n\nstring str;\nstr = \"Welcome to Blog!\";\n// 선언 이후 초기화\n```\n\n### method?\n\nString Class에서는 다양한 메소드들도 제공합니다.\n\n다음 세 개 정도만 알아두어도 간단한 문자열 컨트롤은 가능합니다.\n\n1. length()\n2. size()\n3. find()\n\n간단히 사용 방법을 알아봅시다!\n\n#### length(), size()\n\n일반적으로, `length()`와 `size()`는 같은 값을 반환합니다.\n\n이 둘이 완벽하게 같은 기능을 한다고 알고 있어도 사용하는데 별 무리는 없지만, 의미가 미묘하게 다릅니다.\n\n`length()`메소드는 **문자열의 길이**를 나타내지만, `size()`메소드는 **string 객체가 메모리에서 실제 사용하고 있는 크기**를 나타냅니다.\n\n사용 방법 자체는 둘이 같기때문에 따로 신경써주지 않아도 됩니다.\n\n```cpp\nstring str = \"Hello!\";\n\ncout << str.length(); // 6\n\ncout << str.size(); // 6\n```\n\n#### find()\n\n`find()`는 문자열을 찾고, 그 문자열의 시작 위치를 반환하는 메소드입니다.\n\n첫번째 인자로 찾을 '문자'나 '문자열'을 입력해주고, 두번째 인자로는 찾기 시작할 '위치'를 입력해줍니다.\n\n두번째 인자의 default값은 0으로, 입력해주지 않으면 처음부터 탐색합니다.\n\n`\"Welcome to my blog!\"`라는 문자열에서 `\"my\"`라는 문자열의 시작 위치를 출력하는 예제입니다.\n\n```cpp\nstring str = \"Welcome to my blog!\";\n\ncout << str.find(\"my\"); // 11\n```\n\n`\"W\"`가 0번 index이므로 `\"my\"`가 처음 시작하는 위치인 11이 출력된 것을 볼 수 있습니다.\n\n다음은 `\"abbbba\"`라는 문자열에서 두번째 `\"a\"`라는 문자의 시작 위치를 출력하는 예제입니다.\n\n```cpp\nstring str = \"abbbba\";\n\ncout << str.find(\"a\", str.find(\"a\") + 1); // 5\n```\n\n위 예제에서 두번째 인자로 입력한 `str.find(\"a\")`는 0번째 index의 `\"a\"`를 찾고 0을 반환할 것입니다.\n\n이 값에 1을 더해줘서 첫번째로 `\"a\"`가 등장한 위치 다음부터 탐색하도록 하여 2번째 `\"a\"`의 위치를 찾아 5라는 값을 반환하게 됩니다.\n","excerpt":"C++의 문자열? C++은 문자열을 쉽게 다룰 수 있는 String Class를 제공합니다. C++에서 String Class를 사용하기 위해서는 String 헤더 파일을 포함해야 합니다. 또한, String Class는 std namespace…","fields":{"slug":"/cpp11/"},"frontmatter":{"date":"Apr 04, 2020","title":"바닥에서 시작하는 C++ (11) - 문자열(String)","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Alfred\n\n오늘 소개할 어플은 Alfred입니다.\n\n![Alfred4](1.png)\n\n원래 Paste2를 사용하고 있었는데, 갑자기 구독형으로 정책을 바꾸는바람에 대체 앱을 서칭하다 발견했습니다.\n\n(~~비싸긴 하지만~~)Paste2보다 훨씬 기능도 강력하고, 무엇보다도 'Snippet'기능이 마음에 쏙 들었습니다.\n\n기능을 좀 살펴본 후 아무 고민도 없이 갈아탔습니다!\n\nAlfred의 Default 단축키는 `⌥ + Space`로 설정되어있습니다.\n\n![search](3.png)\n\n눌러보면, 기존 맥의 Spotlight 검색 기능과 매우 비슷한 검색창이 나옵니다.\n\n여기에 `alfred`를 검색하고 엔터를 누르면 다음과 같은 preference창을 볼 수 있습니다.\n\n![Preference](2.png)\n\n저는 우선 Appearance부터 설정해줬습니다. 앞서 설명했던 Search Bar의 테마를 설정할 수 있습니다.\n\n기본제공되는 테마를 쓰려 했지만 별로 마음에 드는게 없어서 테마를 따로 만들었습니다.\n\n![appearance](4.png)\n\n테마를 만드는 과정이 굉장히 쉽고 간단하기 때문에 마음에 들지 않는다면 본인의 입맛에 맞는 테마를 만들어 쓰면 됩니다.\n\n이제 Snippet 기능을 본격적으로 사용해봅시다!\n\n### Snippets\n\n![snippets](5.png)\n\nFeatures 탭에서 Snippets라는 기능을 설정해 줄 수 있습니다.\n\n흔히 말하는 자동 완성 기능이라고 생각하면 쉽습니다.\n\n![](6_1.png)\n\n설정 창은 위와 같이 생겼으며, 우측 상단의 \"Automatically expand snippets by keyword\"를 체크하게 되면 따로 동작을 추가로 입력하지 않아도 자동으로 keyword를 인식하고 자동으로 입력해줍니다.\n\n예시로 몇 개를 만들어두었는데, 사용법은 굉장히 간단합니다.\n\n좌측은 Collection입니다. 같은 기능을 하는 Snippet들을 묶어서 정리할 수 있으며, 공통된 prefix를 지정해줄 수 있습니다.\n\n저는 C++ 관련 Snippet의 prefix를 `#`으로 설정해 두었습니다.\n\n이 Snippet들 중 CPP initial이라는 항목은 어떻게 설정되어있는지 보도록 하겠습니다.\n\n![](7.png)\n\nname에는 그 Snippet의 기능을 설명해주는 이름이면 충분하고, keyword는 Collection에서 지정해주었던 prifix와 함께 쓰여서 동작하게되므로 본인이 편한 약어를 지정해주면 됩니다.\n\n예를 들어, CPP initial이라는 이름의 Snippet은 Collection의 prifix가 `#`이고 keyword가 `init`이므로, `#init`을 입력하게 되면 다음과 같이 설정해둔 내용으로 바로 변환되어 입력됩니다.\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\t\n\treturn 0;\n}\n```\n\n이를 통해 반복적인 작업을 최대한 줄여줄 수 있습니다.\n\nSnippet 설정창의 왼쪽 아래부분 Curly bracket(`{ }`)을 통해 Placeholder를 설정해줄 수도 있습니다.\n\nPlaceholder를 통해 출력할 수 있는 기능은 아래와 같습니다.\n\n1. 오늘 날짜 출력\n2. 다른 날짜 출력\n3. 클립보드 히스토리\n4. 랜덤 출력\n5. Snippet 실행 후 최종 커서 위치 설청\n\n이를 이용하면 그 때마다 상황에 맞는 데이터를 출력해줄 수 있습니다.\n\nPlaceholder의 사용법에 대한 더 자세한 설명은 다음 링크에서 확인할 수 있습니다.\n\n[https://www.alfredapp.com/help/workflows/advanced/placeholders/](https://www.alfredapp.com/help/workflows/advanced/placeholders/)","excerpt":"Alfred 오늘 소개할 어플은 Alfred입니다.  원래 Paste2를 사용하고 있었는데, 갑자기 구독형으로 정책을 바꾸는바람에 대체 앱을 서칭하다 발견했습니다. (비싸긴 하지만)Paste2보다 훨씬 기능도 강력하고, 무엇보다도 'Snippet…","fields":{"slug":"/Alfred/"},"frontmatter":{"date":"Apr 04, 2020","title":"MAC 필수 어플 - Alfred(Snippet)","tags":["MAC"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 2주차 Linux(Ubuntu)로 살아보기\n\n![](1.png)\n\n18.04버전의 화면 모습입니다. 알아보니 원래 Ubuntu는 'GNOME'이라는 데스크탑 환경을 채택했다가, 'Unity'환경으로 바꾸었었고, 이제 다시 18.04버전부터 'Unity'와 상당히 유사하게 디자인 된 테마를 달고 나온 'GNOME'이 다시 기본 데스크탑 환경으로 채택되었다고 합니다.\n\n기대했던 것보다 훨씬 깔끔하게 디자인되어 있는 것 같아서 나쁘지 않다는 생각을 했습니다. 하지만, 몇몇 프로그램을 시작해보면서 불편함을 느끼기 시작했습니다.\n\n![](2.png)\n\nUbuntu를 설치하고 가장 먼저 실행해본 것은 Firefox!\n\n뭔가 벌써 불편함이 느껴지지는 않으신가요?\n\n아마 불편함을 느꼈다면 저와 같은 생각이실겁니다.\n\n![](3_1.png)\n\n안그래도 좌측의 런처(Launcher)때문에 작업 화면이 손해를 보고 있는데, 상단바 때문에 상당히 큰 공간이 낭비되고 있다는게 보이시나요?\n\n심지어 메뉴바도 활성화되지 않은 상태입니다. 만약 메뉴바가 활성화되어있었다면 더 큰 공간을 차지하게 되는 것이죠.\n\n인터넷을 뒤져보니 이런 불편함을 호소하는 사람들은 저뿐만이 아니었고, 해결 방법을 어렵지 않게 찾을 수 있었습니다.\n\n### 1. Top Bar 제거하기 - Unite\n\n우선 [https://addons.mozilla.org/ko/firefox/addon/gnome-shell-integration/](https://addons.mozilla.org/ko/firefox/addon/gnome-shell-integration/)에 들어가서 Add-On을 설치해줍니다.\n\n그 후, 바탕화면에서 우클릭 후 'Open Terminal'로 Terminal을 엽니다\n\n![](4.png)\n\n위와 같이 Terminal이 열렸다면 다음처럼 입력해줍니다.\n\n```\n$ sudo apt-get install chrome-gnome-shell\n```\n\n이제 Unite를 설치해주어야 하는데, Unite는 패키지 의존성이 있기 때문에 터미널에 다음과 같이 입력해서 패키지를 먼저 설치해줍니다.\n\n```\n$ sudo apt install x11-utils gnome-shell-extension-dashtodock\n```\n\n![](5.png)\n\n이제 Unite plugin을 설치해줄 차례입니다!\n\n[https://extensions.gnome.org/](https://extensions.gnome.org/)\n\n위 링크에 접속해줍니다. 그 후, Unite를 검색해서 설치해주면 됩니다.\n\n![](6.png)\n\nUnite를 눌러 들어가준 뒤, 아래 사진의 표시한 부분을 클릭하여 On으로 만들어줍니다.\n\n![](7.png)\n\n설치할 것이냐고 묻는 팝업창이 뜨고, 여기서 Install을 선택하게 되면,\n\n다음과 같이 Top Bar와 Title Bar, Menu Bar가 공간을 같이 사용하면서 차지하는 공간이 줄어들게 됩니다.\n\n![](8.png)\n\n어떤 차이인지 비교해볼까요?\n\n![](9.png)\n\n왼쪽에 있는 창이 Unite를 설치한 후의 모습이고, 오른쪽에 있는 창이 Unite를 설치하기 전의 모습입니다.\n\n실질적으로는 Title Bar 크기 만큼의 공간이 확보가 된 것인데, 이정도 크기 확보로도 전보다는 훨씬 시원시원한 느낌이 드는 것 같습니다.\n\n### 2. SleepMode 방지 - Caffeine\n\nUbuntu를 사용하다 보니, Ubuntu를 실행시키고 이것저것 검색하거나 글을 쓰다 들어오면,\n\n![](10.png)\n\n어느 순간 이렇게 위처럼 SleepMode가 되어 잠겨버리고 다시 로그인해야하는 상황이 종종 있었습니다.\n\n이게 또 생각보다 거슬릴 때가 많아서 방법을 모색하던 중, extension 설치를 통해 해결할 수 있다는 사실을 알았습니다.\n\n그 extension의 이름이 바로 Caffeine입니다. \n\nUbuntu를 잠들지 못하게 하겠다는 의지가 담긴 이름같습니다. ~~정말 이름한번 잘 지은 것 같습니다.~~\n\n![](11_1.png)\n\nUbuntu Software에서 우측 상단의 검색 버튼을 눌러 'Caffeine'을 검색한 후, 설치를 진행합니다.\n\n![](12.png)\n\n설치가 완료된후, Caffeine을 실행시키게 되면 우측 상단에 컵 모양 아이콘이 생기게 됩니다.\n\n![](13.png)\n\n이 아이콘을 클릭한 후 'Activate'를 선택하게 되면,\n\n![](14.png)\n\n다음과 같이 컵에서 김이 올라오며 실행된 것을 볼 수 있습니다.\n\n![](15.png)\n\n이렇게 실행해 두면 Ubuntu를 가만히 두더라도 SleepMode가 실행되지 않는 것을 확인했습니다\n\n더 이상 귀찮게 암호를 다시 입력해서 잠금을 해제해야하는 일이 생기지 않겠네요ㅎㅎ\n\n## 느낀 점\n\nUbuntu를 사용해보면서, 정말 많은 사람들이 함께 만들어가고 있다는 느낌을 받았습니다.\n\n무언가 사용하다 불편한 점이 있다고 한다면 인터넷 서칭을 하다보면 비슷한 불편함을 겪었던 사람들을 찾을 수 있고, 해결책 또한 쉽게 찾을 수 있다는 것이 정말 마음에 들었습니다.\n\n누군가 불편함을 느끼면 그것을 해결하기 위해 다함께 노력하고, 공유하는 그 시스템을 보고, 몸소 느끼면서 Linux의 매력을 알 수 있었던 한주였습니다.\n\n'Firefox 브라우저 디자인이 보기 안좋다! 이렇게 수정했으면 좋겠다'라는 의견이 있으면 그 문제를 해결하는 방법을 찾아내고 서로 공유했기에 제가 이렇게 쉽고 빠르게 해결 방안을 찾고 문제를 해결할 수 있었고,\n\n마찬가지로 'Ubuntu가 SleepMode에 들어가지 않았으면 좋겠다!'라는 의견이 있으면 그 문제를 해결하는 소프트웨어를 만들어내고 공유해서 많은 사람들이 쓸 수 있도록 했기 때문에 저는 간단하게 그 소프트웨어를 내려받음으로써 불편함을 해소할 수 있었습니다.\n\n이렇게 잘 구축된 운영체제와 커뮤니티가 서로 맞물려 상호작용하면서 긍정적인 작용을 하고있는 것을 느낄 수 있었습니다.\n\nLinux의 어찌보면 가장 두드러지는 특징이라고 할 수 있는 '오픈소스 소프트웨어'를 직접 체험해보고 몸소 장점을 느껴봤다는 점에서 의미있는 시간이었다고 생각합니다.\n\n---\n이번주는 Ubuntu를 사용하면서 불편한 점을 해소하는 방법을 알아봤다면,\n\n다음주부터는 간단한 코딩을 Ubuntu를 통해 해보거나 다른 응용프로그램들을 설치해서 직접 사용해보는 활동들을 주로 해보도록 하겠습니다.","excerpt":"2주차 Linux(Ubuntu)로 살아보기  18.04버전의 화면 모습입니다. 알아보니 원래 Ubuntu는 'GNOME'이라는 데스크탑 환경을 채택했다가, 'Unity'환경으로 바꾸었었고, 이제 다시 18.04버전부터 'Unity…","fields":{"slug":"/linux2/"},"frontmatter":{"date":"Mar 29, 2020","title":"Linux(Ubuntu)로 살아보기 (2) - Unite, Caffeine","tags":["Linux(Ubuntu)"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Linux로 살아보기\n\n'Linux로 살아보기'라는 과제를 받았습니다.\n\nLinux 운영체제를 설치하고, 그 위에서 직접 일주일에 한 개 이상씩의 프로그램들을 설치하고 실행시켜보면서 Linux라는 운영체제에 익숙해지는 것이 이 과제의 목표입니다.\n\n### 첫 번째 선택\n\nLinux를 설치하기 전, 첫번째로 선택해야하는 것은 'Linux를 메인 운영체제로 사용할 것이냐, 아니면 가상 머신을 통해 사용할 것이냐'입니다. \n\n저는 메인 운영체제로 macOS Catalina를 사용하고 있기 때문에 가상 머신을 통해 Linux를 사용하기로 했습니다.\n\n### 두 번째 선택\n\n가상 머신을 통해 Linux를 사용하기로 했으니, 어떤 가상머신을 통해 Linux를 설치할 것인지에 대해 생각을 해보아야 합니다.\n\n고려할수 있는 가상머신은 총 3개 정도였습니다.\n\n1. VirtualBox\n\n2. VMware Fusion\n\n3. Parallels Desktop\n\n#### 1. VirtualBox\n\nVirtualBox는 우선 공짜로 쓸 수 있다는 점에서 메리트가 있었지만, 사용할 수 있는 메모리와 프로세서 수, 그래픽메모리 용량 등에 제약이 많았습니다.\n\n간단한 동작을 수행하는데에도 눈에 거슬릴 정도로 많이 버벅이며 느리다는 생각이 들었습니다.\n\n#### 2. VMware Fusion\n\nVMware Fusion은 Parallels Desktop과 macOS의 가상머신 양대산맥으로 손꼽히는 프로그램입니다.\n\n하지만, 기능적인 측면에서 Parallels에 많이 밀린다는 느낌을 강하게 받았습니다.\n\n#### 3. Parallels Desktop\n\nParallels Desktop이 VMware Fusion보다 [기능이 많고](https://www.parallels.com/kr/landingpage/pd/fusion-compete/?gclid=Cj0KCQjw6_vzBRCIARIsAOs54z53ur3lxesgA0yBwiU8TOixP3TGoXNmc93yYwbI02PlTeSQX17rmfwaAnRsEALw_wcB) Parallels Tools를 이용한 다양한 기능들도 사용할 수 있었습니다.\n\n무엇보다도 이 혜택이 가장 큰 메리트가 아닐까 싶습니다.\n\n![](free.png)\n\n결과적으로 Parallels Desktop을 통해 Linux 설치를 진행하게 되었습니다.\n\n### 세 번째 선택\n\n이제는 어떤 종류의 Linux를 사용할지를 선택할 시간입니다.\n\n사실 이 선택이 가장 쉬웠습니다. 고려 대상은 다음과 같았습니다. \n\n1. 관련 Document가 많으며 정보를 쉽게 찾을 수 있는가?\n\n2. 설치 및 설정, 유지/보수가 간편한가?\n\n새로운 기술을 습득하고 학습함에 있어 매우 중요하다는 사실을 느낀 경험이 많기 때문에 널리 사용되며 커뮤니티도 많이 활성화된 Ubuntu를 사용하기로 결정했습니다.\n\n## 설치\n\n우선 다음과 같이 Parallels에서 Ubuntu를 바로 설치할 수도 있지만, 저는 iso 파일을 통해 따로 설치하겠습니다.\n\n![](1.png)\n\n[이 링크](https://ubuntu.com/download/desktop)를 통해 Ubuntu iso 파일을 내려받을 수 있습니다.\n\n링크로 들어가면 다음과 같은 화면이 나오는데, 저는 LTS 버전(Long-Term Service)을 설치해주도록 하겠습니다.\n\n![](install.png)\n\n제가 설치하는 날짜 기준 Ubuntu 18.04.4 LTS 버전이 배포되고 있으며, 배포 시작일로부터 5년(2023년 4월까지) 서비스를 해준다고 명시되어 있습니다.\n\n설치가 완료되면, Parallels에서 'DVD 또는 이미지 파일의 Windows나 다른 OS 설치'항목을 선택하여 설명대로 설치를 진행합니다.\n\n![](2.png)\n\n![](3.png)\n\n![](4.png)\n\n![](5.png)\n\n![](6.png)\n\n설치가 완료되었습니다! 그럼 기본 설정을 마저 해보도록 합시다.\n\n## 설정\n\nUbuntu의 전원을 종료한 뒤, Parallels 우클릭 후 제어 센터를 선택하면 다음과 같은 창이 나옵니다.\n\n![](7.png)\n\n여기서 톱니바퀴 모양을 눌러 설정을 해줍시다!\n\n![](8.png)\n\n여기에서 가상 머신의 CPU 및 메모리, 그래픽 등을 설정해줄 수 있습니다.\n\n![](9.png)\n\n하드웨어 - CPU 및 메모리 탭에서는 프로세서 수와 메모리를 설정해줄 수 있습니다.\n\n저는 총 12개의 프로세서 중 6개, 16GB의 메모리 중 8GB를 사용하기로 했습니다.\n\n![](10.png)\n\n하드웨어 - 그래픽 탭에서는 그래픽 메모리 값을 설정해줍니다. \n\n저는 최대 2GB중 1GB를 사용하기로 했습니다.\n\n위와 같이 설정을 마치고 나면, 보다 쾌적한 환경에서 Ubuntu를 실행할 수 있게 됩니다.\n\n## 느낀점\n\n무엇보다도, 설치를 하는 과정에서 Linux 운영체제가 그리 어렵지만은 않다는 생각이 들었다는 것이 가장 충격이었습니다.\n\n엄청 복잡하고 처음 시작하는 사람은 접근하기가 어렵다는 선입견을 가지고 있었는데, Ubuntu는 그 고정관념을 깨기에 충분했던 것 같습니다.\n\n다음 포스트부터는 한 주에 하나씩 Ubuntu에서 프로그램을 하나씩 설치하고 사용해가며 적응해야 할 텐데,\n\n그 과정이 생각보다 어렵고 힘들지만은 않을 것 같다는 희망이 생긴 것 같습니다.\n\n","excerpt":"Linux로 살아보기 'Linux로 살아보기'라는 과제를 받았습니다. Linux 운영체제를 설치하고, 그 위에서 직접 일주일에 한 개 이상씩의 프로그램들을 설치하고 실행시켜보면서 Linux…","fields":{"slug":"/UbuntuInstall/"},"frontmatter":{"date":"Mar 22, 2020","title":"Linux(Ubuntu)로 살아보기 (1) - 설치 및 설정","tags":["Linux(Ubuntu)",null],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## What is STL?\n\nSTL(Standard Template Library)는 표준 C++ Library입니다.\n\n프로그램에 필요한 자료구조와 알고리즘을 Template로 제공해줍니다.\n\n이 포스트에서 설명할 array Template는 STL에 Sequence Container(시퀀스 컨테이너)중 하나의 요소입니다.\n\nSTL Sequence Container에는 vector, array, deque, list, forward_list가 있습니다.\n\nSTL Container에 관한 더 자세한 설명은 [이 링크](https://docs.microsoft.com/ko-kr/cpp/standard-library/stl-containers?view=vs-2019)를 통해 볼 수 있습니다.\n\n\n## Why STL Array?\n\n[앞선 포스트](https://mintyu.github.io/cpp09/)에서 설명했듯, 이미 C++에는 C 스타일의 static array를 지원하고 있었습니다.\n\n하지만, 이 static array는 꽤나 사용하기 불편했습니다.\n\n불편한 이유는 다른 언어들을 조금만 둘러보아도 알 수 있습니다.\n\n대부분의 언어들은 배열을 선언할 때 배열에 대한 다양한 부가 정보들(length 등)을 사용할 수 있게 설계되어 있습니다.\n\n하지만, 기존의 static array는 단순히 연속된 메모리 공간의 앞부분을 가르키는 포인터에 불과 했었기 때문에 복잡한 과정을 통해 배열의 길이를 구해야만 했습니다.\n\n물론 vector가 있었긴 하지만, 성능 저하의 부담이 크고 잠재적인 문제가 존재했기 때문에 더 효율적인 array가 필요했습니다.\n\n그렇게 STL Sequence Container에 array가 추가되었습니다.\n\n이렇게 array는 vector보다 더 가볍고 빠르며 일부 STL 컨테이너를 사용할 수 있게 되었습니다.\n\n## array Class\n\narray를 사용하기 위해서는 우선 `#include <array>`로 array 헤더파일을 불러와야 합니다.\n\n그리고 array를 선언하기 위한 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> array<타입, 크기> 배열 이름; \n> // 선언 먼저 하는 경우\n> \n> array<타입, 크기> 배열 이름 = {원소1, 원소2, 원소3, ...};\n> // 선언과 동시에 초기화하는 경우\n> ```\n\n주의할 점은, 이 배열의 원형은 `std::array`이므로 직접 `std::`를 입력하거나 `using namespace std;`를 이용해야합니다.\n\n해당 포스트에서는 `using namespace std;`를 입력했다고 가정한 후 설명하겠습니다.\n\n> 예제\n> ``` cpp\n> array<int, 4> arr1 = {0, 1, 2, 3};\n>\n> array<int, 4> arr2 = {0, 1, 2};\n> // exactly same with {0, 1 ,2, 0}\n> \n> array<int, 4> arr3 = {0, 1, 2, 3, 4};\n> // not allowed\n> \n> array<int, > arr4 = {0, 1, 2, 3};\n> // not allowed\n> ```\n\n`arr1`과 같이 선언이 가능하며, `arr2`처럼 주어진 크기보다 적은 개수의 원소로 초기화해주었을 때, 부족한 만큼은 0으로 초기화됩니다.\n\n`arr3`과 같이 주어진 크기보다 많은 수의 원소는 대입할 수 없습니다.\n\n또한, [static array](https://mintyu.github.io/cpp09/)와는 다르게 `arr4`처럼 크기를 입력하지 않으면 오류가 발생합니다.\n\n### index 접근(at)\n\n이 array도 일반 static array처럼 `[ ]`를 통해 접근이 가능합니다.\n\n> ``` cpp\n> array<int, 4> arr1 = {0, 1, 2, 3};\n> \n> cout << array[1]; // 1\n> \n> array[2] = 4;\n> cout << array[2]; // 4\n> ```\n\n하지만, 이 문법의 문제는 유효 범위 검사를 하지 않는다는 점입니다.\n\n아래의 간단한 예제를 보도록 합시다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> using namespace std;\n> \n> int main()\n> {\n> \tint a;\n> \tcin >> a;\n> \tint arr[3]= {1, 2, 3};\n> \tcout << arr[a];\n> \treturn 0;\n> }\n> ```\n\n별 문제없이 잘 실행됩니다. 하지만 a에 입력값으로 3 이상의 수를 준다면?\n\n![](1.png)\n\n갑자기 이상한 값을 출력합니다.\n\n그 원인은 index가 범위를 벗어난 것을 검사하지 않고, 초기화되지 않은 메모리에 접근했기 때문입니다.\n\n이런 경우 프로그램이 커졌을 때, 오류를 따로 발생시키지 않게 되면 디버깅 작업이 상당히 까다로워집니다.\n\n따라서, 유효 범위를 검사해서 따로 예외를 발생시켜주는 `at( )`을 사용하여 접근하는 것이 더 안전합니다.\n\n물론, 유효 범위 검사를 진행하기 때문에 operator `[ ]`로 접근하는 것보다는 속도가 약간 느립니다.\n\n`at( )`은 다음과 같이 쓸 수 있습니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> #include <array>\n> \n> using namespace std;\n> \n> int main()\n> {\n> \tint a;\n> \tcin >> a;\n> \tarray<int, 3> arr = {1, 2, 3};\n> \tcout << arr.at(a);\n> \treturn 0;\n> }\n> ```\n\n앞서 operator로 접근한 예제와 같은 예제이지만, a에 3이상의 수를 입력하게 된다면?\n\n![](2.png)\n\n이처럼 at이 out\\_of\\_range 예외를 발생시켰습니다.\n\n이와 같은 접근 방식은 조금 더 안전한 코드를 만들 수 있습니다.\n\n### 배열의 길이(size)\n\n배열의 길이를 출력하는 방법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> 배열이름.size();\n> ```\n\nstatic array보다 훨씬 간단한 방법으로 배열의 길이를 출력할 수 있습니다.\n\n### 배열 정렬(sort)\n\n사실 정렬은 std::array에서 정의된 함수는 아니지만, 유용하게 사용할 수 있기 때문에 사용법을 알아두는것이 좋습니다.\n\n`sort( )`는 `#include <algorithm>`을 통해 헤더파일을 불러와야 사용할 수 있습니다.\n\n기본적으로 오름차순으로 정렬하게 됩니다.\n\n> 문법\n> ``` cpp\n> sort(배열의 첫번째를 가르키는 반복자, 배열의 마지막을 가르키는 반복자);\n> ```\n\nsort 함수는 다음과 같이 사용할 수 있습니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> #include <array>\n> #include <algorithm>\n> \n> using namespace std;\n> \n> int main()\n> {\n> \tarray<int, 5> arr = {7, 8, 1, 2, 3};\n> \tsort(arr.begin(), arr.end()); // sort arr\n> \tfor (int i = 0; i < 5; i++)\n> \t{\n> \t\tcout << arr[i] << \" \"; // 1 2 3 7 8\n> \t}\n> \t\n> \treturn 0;\n> }\n> ```\n\n`sort( )`의 인자로 준 값들은 반복자(iterator)를 의미합니다.\n\n이 예제에서는 배열의 정렬 시작과 끝 지점을 나타내는 용도로 사용되었습니다.\n\n`begin( )`과 `end( )`는 각각 배열의 첫 번째 반복자와 마지막 반복자를 리턴하는 기능이라는 것까지만 알아두어도 좋습니다.\n\n이 포스트에서는 \"array의 정렬이 가능하다!\" 까지만 이해해도 충분합니다.\n\n반복자(iterator)와 `sort( )`에 대한 설명은 다음에 더 자세히 하도록 하겠습니다.\n\n## Summary\n\n이번 포스트에서는 STL Sequence Container중 하나인 `std::array`, 즉 배열에 대해 알아보았습니다.\n\n또한, 이 배열의 값에 접근하고, 길이를 출력하고, 정렬하는 방법에 대해서도 알아보았습니다.\n\n이 `std::array`에 대한 더 자세한 정보는 [이 링크](https://docs.microsoft.com/ko-kr/cpp/standard-library/array-class-stl?view=vs-2019)를 통해 볼 수 있습니다.","excerpt":"What is STL? STL(Standard Template Library)는 표준 C++ Library입니다. 프로그램에 필요한 자료구조와 알고리즘을 Template로 제공해줍니다. 이 포스트에서 설명할 array Template는 STL…","fields":{"slug":"/cpp10/"},"frontmatter":{"date":"Mar 15, 2020","title":"바닥부터 시작하는 C++ (10) - 배열(STL)","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 배열(Array)\n\n배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의할 수 있습니다.\n\n배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 합니다.\n\nC++에서 인덱스는 언제나 0부터 시작하며, 0을 포함한 양의 정수만을 가질 수 있습니다.\n\n \n\n배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조입니다.\n\n \n\n배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열뿐만 아니라 그 이상의 다차원 배열로도 선언할 수 있습니다.\n\n하지만 현실적으로 이해하기가 쉬운 2차원 배열까지가 많이 사용됩니다.\n\n### 배열 선언\n\n배열은 다음과 같이 선언할 수 있습니다.\n\n> 문법\n> ``` cpp\n> 타입 배열이름 [배열 길이];\n> ```\n\n변수와 마찬가지로 선언 후 따로 초기화해줄 수도 있으며, 선언과 동시에 초기화해줄 수도 있습니다.\n\n> 예제\n> ``` cpp\n> // 선언 후 초기화\n> int arr1[3];\n> \n> arr[0] = 1;\n> arr[1] = 2;\n> arr[2] = 3;\n> \n> // 선언과 동시에 초기화\n> int arr2[3] = {11, 22, 33};\n> \n> int arr3[3];\n> arr3[3] = {111, 222, 333}; // 오류 발생!\n>\n> int arr0[3] = { }; // int arr0[3] = {0, 0, 0}와 같다\n> \n> ```\n\n주의할 점은, `arr3`처럼 배열을 선언해놓은 후 `arr3[3] = {111, 222, 333}`처럼 초기화는 불가능합니다. \n\nCurly Bracket(`{ }`)으로 초기화하려면 선언과 동시에 초기화해주어야 합니다.\n\n뿐만 아니라, `arr1`과 `arr2`의 index 크기가 같다고 해서 다음과 같이 대입할 수 없습니다.\n\n`arr0`처럼 빈 괄호(`{ }`)로 배열을 초기화하면 모든 항목이 0으로 초기화됩니다.\n\n``` cpp\narr1 = arr2 // 오류 발생!\n```\n\n### 배열의 길이 \n\n배열의 길이, 즉 원소의 개수를 구하는 방법은 다음과 같습니다.\n\n``` cpp\nsizeof(배열 이름) / sizeof(배열 이름[0])\n```\n\n여기서 `sizeof(arg)`함수는 arg의 크기를 byte로 반환하는 함수입니다.\n\n따라서 `sizeof(배열 이름)`은 배열 전체에 할당된 메모리의 크기를 나타내며, `sizeof(배열이름[0])`은 첫번째 인덱스에 있는 요소의 크기를 나타냅니다.\n\n배열에는 모두 같은 종류의 요소들이 들어가므로, `sizeof(배열 이름) / sizeof(배열 이름[0])`은 첫번째 인덱스와 같은 크기의 요소들이 배열에 총 몇개 존재하는지를 나타냅니다.\n\n\n그렇다면, 만약 다음처럼 index의 길이를 지정해주지 않으면 어떤 일이 일어날까요?\n\n``` cpp\nint noIndex[] = {0, 1, 2, 3, 4};\nint index = sizeof(noIndex) / sizeof(noIndex[0])\n\ncout << index // 5\n```\n\n이렇게 배열의 길이를 지정해주지 않게 되면, 배열의 요소 개수에 맞춰 자동으로 배열의 길이가 설정됩니다.\n\n## Array Template Class?\n\nC++11부터는 array의 템플릿 클래스가 추가되었습니다.\n\n`#include <array>`를 통해 기존 C 스타일이 아닌 새로운 형태로 더 간편하게 배열을 정의하고 이용할 수 있습니다.\n\n다음 포스트에서는 이 내용에 대해 다루도록 하겠습니다.","excerpt":"배열(Array) 배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의할 수 있습니다. 배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 합니다. C…","fields":{"slug":"/cpp09/"},"frontmatter":{"date":"Mar 10, 2020","title":"바닥부터 시작하는 C++ (9) - 배열(C style)","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nMAC OS를 사용하는 경우, iTerm에서 VSCode를 간단한 명령어로 호출할 수 있습니다.\n\n다음과 같이 열고자 하는 디렉토리 내에서 `code .`라는 명령어를 입력해주면 현재 경로로 VSCode가 실행됩니다.\n\n![Terminalexample](1.png)\n\n## Setting\n\n하지만, 이를 위해선 간단한 세팅을 해 주어야 합니다.\n\n먼저, 현재 저는 iTerm2 Terminal에 oh-my-zsh를 사용하고 있음을 밝힙니다.\n\n저처럼 iTerm2에 oh-my-zsh 세팅까지 모두 끝냈다면 ~/.zshrc를 편집하는 방법은 알고 있겠지만, 모른다 하더라도 어렵지는 않습니다.\n\niTerm2 터미널을 열고, 다음과 같이 입력합니다.\n\n```\n$ vim ~/.zshrc\n```\n\n위 명령어를 입력했다면, 다음과 같은 화면을 볼 수 있습니다.\n\n![vim](2.png)\n\nShift + g를 눌러 문서의 맨 아래로 이동한 후, o(아랫줄에 insert)를 눌러 편집모드를 켭니다.\n\n그리고 다음과 같이 입력해줍니다.\n\n```\ncode () {VSCODE_CWD=\"$PWD\" open -n -b \"com.microsoft.VSCode\" --args $* ;}\n```\n\n입력이 되었다면, esc버튼을 눌러 편집 모드를 끝낸 뒤에(왼쪽 아래 normal 확인),\n\n:wq를 입력하여 저장하고 나가줍니다.(\":\"을 누르면 명령어 입력창이 활성화됩니다.)\n\n그 후 터미널에서 다음과 같이 `source ~/.zshrc`를 입력하면 터미널에서 명령어를 통해 VSCode를 실행할 수 있게 됩니다!\n\n![source](3.png)","excerpt":"MAC OS를 사용하는 경우, iTerm에서 VSCode를 간단한 명령어로 호출할 수 있습니다. 다음과 같이 열고자 하는 디렉토리 내에서 라는 명령어를 입력해주면 현재 경로로 VSCode가 실행됩니다.  Setting…","fields":{"slug":"/VSCodeShortCut/"},"frontmatter":{"date":"Mar 06, 2020","title":"iTerm(Using Zsh)에서 VSCode 열기 [MAC OS]","tags":["MAC","VSCode"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 반복문(Iteration Statements)\n\n반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문입니다.\n\n프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나입니다.\n\n \n\nC++에서 사용되는 대표적인 반복문의 형태는 다음과 같습니다.\n\n \n\n1. while 문\n\n2. do / while 문\n\n3. for 문\n\n4. 범위 기반의 for 문\n\n### while 문\n\nwhile 문은 특정 조건을 만족하는 한 계속해서 주어진 명령문을 반복 실행합니다.\n\n\nC++에서 while 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> while (조건식)\n> \n> {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n### do / while 문\n\nwhile 문은 루프에 진입하기 전에 먼저 조건식부터 검사합니다.\n\n하지만 do / while 문은 먼저 루프를 한 번 실행한 후에 조건식을 검사합니다.\n\n즉, do / while 문은 조건식의 결과와 상관없이 무조건 한 번은 루프를 실행합니다.\n\n \n\nC++에서 do / while 문의 문법은 다음과 같습니다.\n\n> 문법\n> ```cpp\n> do {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> } while (조건식);\n> ```\n\n### for 문\n\nwhile 문은 우선 조건식이 참(true)인지를 판단하여, 참이면 내부의 명령문을 실행합니다.\n\n내부의 명령문을 전부 실행하고 나면, 다시 조건식으로 돌아와 또 한 번 참인지를 판단하게 됩니다.\n\nfor 문은 while 문과는 달리 자체적으로 초기식, 조건식, 증감식을 모두 포함하고 있는 반복문입니다.\n\n따라서 while 문보다는 좀 더 간결하게 반복문을 표현할 수 있습니다.\n\n \n\nC++에서 for 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> for (초기식; 조건식; 증감식)\n> \n> {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n### 범위 기반의 for 문\n\nC++11부터는 범위 기반의 for 문이라는 새로운 형태의 반복문이 추가되었습니다.\n\n범위 기반의 for 문은 표현식 안에 포함되어 있는 모든 값에 대해 한 번씩 루프를 실행해 줍니다.\n\n \n\n이러한 범위 기반의 for 문은 배열을 자동으로 인식하며, 컨테이너 클래스에서 많이 사용됩니다.\n\n \n\n다음 예제는 범위 기반의 for 문을 사용하여 배열의 모든 값을 출력하는 예제입니다.\n\n> 예제\n> ```cpp\n> int arr[5] = {1, 3, 5, 7, 9};\n> \n>  \n> \n> for (int element : arr)\n> \n> {\n> \n>     cout << element << \" \";\n> \n> }\n> \n> // 1 3 5 7 9\n> ```\n\n\n## 루프 제어\n\n일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행합니다.\n\n하지만 continue 문과 break 문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 도와줍니다.\n\n\n### continue 문\n\ncontinue 문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 해줍니다.\n\n보통 반복문 내에서 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용됩니다.\n\n \n\n다음 예제는 1부터 100까지의 정수 중에서 짝수를 제외하고 홀수만을 출력하는 예제입니다.\n\n> 예제\n> ```cpp\n> int except_num = 2\n> \n>  \n> \n> for (int i = 0; i <= 100; i++)\n> \n> {\n> \n>     if (i % except_num == 0)\n> \n>     {\n> \n>         continue;\n> \n>     }\n> \n>     cout << i << \" \";\n> \n> }\n> // 1 3 5 7 9 ... 97 99\n> ```\n\n### break 문\n\nbreak 문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행합니다.\n\n즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용합니다.\n\n \n\n다음 예제는 1부터 사용자가 입력한 정수까지의 합을 구하는 예제입니다.\n \n> 예제\n> ```cpp\n> int num = 1, sum = 0;\n> int end_num = 10;\n> \n>  \n> \n> while (1) // 무한 루프\n> \n> {\n> \n>     sum += num;\n> \n>     if (num == end_num)\n> \n>     {\n> \n>         break;\n> \n>     }\n> \n>     num++;\n> \n> }\n> \n> cout << \"1부터 \" << end_num << \"까지 더한 값은 \" << sum << \"입니다.\";\n> \n> //1부터 10까지 더한 값은 55입니다.\n> ```\n\n","excerpt":"반복문(Iteration Statements…","fields":{"slug":"/cpp08/"},"frontmatter":{"date":"Mar 05, 2020","title":"바닥에서 시작하는 C++ (8) - 반복문","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 문제\n\n피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.\n\n이를 식으로 써보면 F(n) = F(n-1) + F(n-2) (n>=2)가 된다.\n\nn = 17일때 까지 피보나치 수를 써보면 다음과 같다.\n\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597\n\nn이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 n이 주어진다. n은 45보다 작거나 같은 자연수이다.\n\n## 출력\n\n첫째 줄에 n번째 피보나치 수를 출력한다.\n\n#### <예제 입력 1>\n\n`10`\n\n#### <예제 출력 1>\n\n`55`\n\n## 풀이\n\n다이나믹 프로그래밍(DP)의 가장 대표적인 문제라고 할 수 있는 문제이다.\n\n규칙에 맞게 피보나치 수를 구해서 출력하기만 하면 되는 간단한 문제이다.\n\n피보나치 수는 앞의 두 수의 합이므로 `fib(a)`가 a번째 피보나치 수라고 가정하였을 때,\n\n`fib(a) = fib(a-1) + fib(a-2)`가 된다.\n\n따라서, 다음과 같이 재귀형으로 함수를 호출하며 피보나치 수를 구할 수 있다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint fib(int a) {\n\n    switch (a)\n    {\n\n    case 0:\n        return 0;\n        break;\n\n    case 1:\n        return 1;\n        break;\n\n\n    default:\n        return fib(a-1) + fib(a-2);\n        break;\n    }\n\n}\n\nint main() {\n\n    int a;\n\n    cin >> a;\n\n    cout << fib(a);\n\n    return 0;\n}\n```\n\n위 예제를 실행하고 `1, 2, 3, 4` 등을 입력하면 정상적으로 `1, 1, 2, 3`이 출력되는것을 확인할 수 있다.\n\n하지만, 문제의 입력 조건의 최댓값으로 주어진 `45`를 입력해보자.\n\n문제의 답이 출력되긴 하지만, 제한시간인 1초를 훨씬 넘겨서 뒤늦게 답이 출력되는 것을 볼 수 있다.\n\n따라서 위의 예제처럼 작성하여 제출하게 되면 다음처럼 제한시간이 초과된다.\n\n![시간 초과](1.png)\n\n그 이유는, 피보나치 수를 계산하는 과정에서 했던 계산을 계속하기 때문이다.\n\n`fib(10)`을 예로 들어보자.\n\n`fib(10) = fib(9) + fib(8)`\n\n`fib(10) = (fib(8) + fib(7)) + (fib(7) + fib(6))`\n\n`fib(10) = ((fib(7) + fib(6)) + (fib(6) + fib(5)) + ((fib(6) + fib(5)) + (fib(4) + fib(3))`\n\n`...후략`\n\n계산은 아직 절반도 하지 않았는데, `fib(8)`은 2번, `fib(7)`은 3번, `fib(6)`은 4번이나 호출되었다.\n\n시간이 초과되지 않기 위해서는, 조금 근본적인 방법으로부터 접근할 필요가 있다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n\n    long long a[1000] = {0, 1, };\n\n    int count;\n\n    cin >> count;\n\n    for (int i = 2; i <= count; i++)\n    {\n\n        a[i] = a[i-1]+a[i-2];\n\n    }\n\n    cout << a[count];\n\n    return 0;\n}\n```\n\n위의 코드는 1차원 배열을 통해 함수를 재귀호출하지 않고 피보나치 수를 구한다.\n\n배열의 크기는 상관없기에 넉넉하게 잡았으며, 배열 안에 들어갈 수는 integer의 범위를 벗어날 수도 있기에 long long으로 설정해주었다.\n\n이 예제를 실행하고 45번째 피보나치 수를 구해도, 심지어 100번째 피보나치 수를 구한다 하더라도 즉각 답을 출력해주는 것을 볼 수 있다.\n","excerpt":"문제 피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다. 이를 식으로 써보면 F(n) = F(n-1) + F(n-2) (n>=2)가 된다. n…","fields":{"slug":"/BOJ02747/"},"frontmatter":{"date":"Mar 02, 2020","title":"백준 [2747] - 피보나치 수(C++)","tags":["백준알고리즘(C++)"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 조건문(Conditional Statements)\n\n조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문입니다.\n\n\nC++에서 사용하는 대표적인 조건문의 형태는 다음과 같습니다.\n\n \n\n1. if 문\n\n2. if / else 문\n\n3. if / else if / else 문\n\n4. switch 문\n\n### if 문\n\nif 문은 조건식의 결과가 참(true)이면 주어진 명령문을 실행하며, 거짓(false)이면 아무것도 실행하지 않습니다.\n\nC++에서 if문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식)\n> \n> {\n> \n>     조건식의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n위의 코드에서 블록에 속한 명령문은 중괄호({})를 기준으로 오른쪽으로 들여쓰기가 되어 있는 것을 볼 수 있습니다.\n\n이처럼 들여쓰기를 통해 코드의 가독성을 높이는 것을 인덴트(indent)라고 하며, 될 수 있으면 모든 코드를 인덴트하는 것이 좋습니다.\n\n### if / else 문\n\nif 문과 함께 사용하는 else 문은 if 문과는 반대로 주어진 조건식의 결과가 거짓(false)이면 주어진 명령문을 실행합니다.\n\n\nC++에서 if / else 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식)\n> \n> {\n> \n>     조건식의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else\n> \n> {\n> \n>     조건식의 결과가 거짓일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n위 식은 [여기](https://mintyu.github.io/cpp06/#%EC%82%BC%ED%95%AD-%EC%97%B0%EC%82%B0%EC%9E%90ternary-operator)에 설명했듯 아래 식처럼 삼항연산자를 통해 짧게 나타낼 수도 있습니다.\n> ``` cpp\n> 조건식 ? 반환값1(True) : 반환값2(False)\n> \n> ```\n\n### if / else if / else 문\n\nif / else if / else 문은 마치 새로운 구문처럼 보이지만, 사실은 두 개의 if / else 문이 연달아 나온 것뿐입니다.\n\n이러한 if / else if / else 문은 조건식을 여러 개 명시할 수 있으므로 중첩된 if 문을 좀 더 간결하게 표현할 수 있습니다.\n\nif / else if / else 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식1)\n> \n> {\n> \n>     조건식1의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else if (조건식2)\n> \n> {\n> \n>     조건식2의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else\n> \n> {\n> \n>     조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n**실행될 명령어가 한줄 뿐이라면 중괄호`{ }`를 생략해서 쓸 수 있습니다.**\n\n### switch 문\n\nswitch 문은 if / else 문과 마찬가지로 주어진 조건 값의 결과에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문입니다.\n\n이러한 switch 문은 if / else 문보다 가독성이 더 좋으며, 컴파일러가 최적화를 쉽게 할 수 있어 속도 또한 빠른 편입니다.\n\n하지만, switch 문의 조건 값으로는 char형, short형, int형 변수나 리터럴과 나중에 배우게 될 열거체까지 사용할 수 있습니다.\n\n따라서 if / else 문보다는 사용할 수 있는 상황이 적은 편입니다.\n\nC++에서 switch 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> switch (조건 값)\n> \n> {\n> \n>     case 값1:\n> \n>         조건 값이 값1일 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n>     case 값1:\n> \n>         조건 값이 값2일 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n>     ...\n> \n>     default:\n> \n>         조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n> }\n> ```\n\ndefault 절은 조건 값이 위에 나열된 어떠한 case 절에도 해당하지 않을 때만 실행됩니다.\n\n이 절은 반드시 존재해야 하는 것은 아니며 필요할 때만 선언할 수 있습니다.\n\n또한, default 절의 위치가 꼭 switch 문의 맨 마지막일 필요는 없습니다.\n\n> 예제\n> ``` cpp\n> switch (num)\n> \n> {\n> \n>     case 1:\n> \n>         cout << \"입력하신 수는 1입니다.\" << endl;\n> \n>         break;\n> \n>     case 2:\n> \n>         cout << \"입력하신 수는 2입니다.\" << endl;\n> \n>         break;\n> \n>     case 3:\n> \n>         cout << \"입력하신 수는 3입니다.\" << endl;\n> \n>         break;\n> \n>     case 4:\n> \n>         cout << \"입력하신 수는 4입니다.\" << endl;\n> \n>         break;\n> \n>     case 5:\n> \n>         cout << \"입력하신 수는 5입니다.\" << endl;\n> \n>         break;\n> \n>     default:\n> \n>         cout << \"1부터 5까지의 수만 입력해 주세요!\" << endl;\n> \n>         break;\n> \n> }\n> ```\n\n각 case 절 및 default 절은 반드시 break 키워드를 포함하고 있어야 합니다.\n\nbreak 키워드는 조건 값에 해당하는 case 절이나 default 절이 실행된 뒤에 전체 switch 문을 빠져나가게 해줍니다.\n\n만약에 break 키워드가 없다면, 조건에 해당하는 switch 문의 case 절 이후의 모든 case 절이 전부 실행될 것입니다.","excerpt":"조건문(Conditional Statements) 조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문입니다. C++에서 사용하는 대표적인 조건문의 형태는 다음과 같습니다. if 문 if / else 문 if / else if…","fields":{"slug":"/cpp07/"},"frontmatter":{"date":"Feb 29, 2020","title":"바닥에서 시작하는 C++ (7) - 조건문","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 연산자(Operator)\n\nC++은 여러 종류의 연산을 위해 다양한 연산자(operator)를 제공하고 있습니다. \n\n\n### 산술연산자(Arithmetic Operator)\n\n| 산술 연산자 |                                설명                                |\n|:-----------:|:------------------------------------------------------------------:|\n|      +      | 왼쪽의 피연산자에 오른쪽의 피연산자를 더함.                        |\n|      -      | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌.                        |\n|      *      | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함.                        |\n|      /      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔.                        |\n|      %      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함. |\n\n> 예제\n> ``` cpp\n> int num1 = 10;\n> \n> int num2 = 4;\n> \n>  \n> \n> cout << \"+ 연산자에 의한 결괏값은 \" << num1 + num2 << \"입니다.\" << endl;\n> // + 연산자에 의한 결괏값은 14입니다.\n> \n> cout << \"- 연산자에 의한 결괏값은 \" << num1 - num2 << \"입니다.\" << endl; \n> // - 연산자에 의한 결괏값은 6입니다.\n> \n> cout << \"* 연산자에 의한 결괏값은 \" << num1 * num2 << \"입니다.\" << endl; \n> // * 연산자에 의한 결괏값은 40입니다.\n> \n> cout << \"/ 연산자에 의한 결괏값은 \" << num1 / num2 << \"입니다.\" << endl; \n> // / 연산자에 의한 결괏값은 2입니다.\n> \n> cout << \"% 연산자에 의한 결괏값은 \" << num1 % num2 << \"입니다.\"; \n> // % 연산자에 의한 결괏값은 2입니다.\n> ```\n\n\n### 대입 연산자(Assignment Operator)\n\n| 대입 연산자 |                                         설명                                         |\n|:-----------:|:------------------------------------------------------------------------------------:|\n|      =      | 왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.                                        |\n|      +=     | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      -=     | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      *=     | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      /=     | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      %=     | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, </br>그 나머지를 왼쪽의 피연산자에 대입함. |\n\n\n> 예제\n> ``` cpp\n> int num1 = 8;\n> \n> int num2 = 8;\n> \n> int num3 = 8;\n> \n>  \n> \n> num1 = num1 + 5;\n> \n> num2 += 5;\n> \n> num3 =+ 5;\n> \n>  \n> \n> cout << \"- 연산자에 의한 결괏값은 \" << num1 << \"입니다.\" << endl;\n> // -  연산자에 의한 결괏값은 13입니다.\n> \n> cout << \"+= 연산자에 의한 결괏값은 \" << num2 << \"입니다.\" << endl;\n> // += 연산자에 의한 결괏값은 13입니다.\n> \n> cout << \"=+ 연산자에 의한 결괏값은 \" << num3 << \"입니다.\";\n> // =+ 연산자에 의한 결괏값은 5입니다.\n> \n> ```\n\n\n\n**주의**\n\n위의 예제에서 num =+ 5 연산은 단순히 숫자 5를 변수 num3에 대입하는 연산이 되었습니다. </br>이처럼 복합 대입 연산자에서 연산자의 순서는 매우 중요하므로 주의를 기울여야 합니다.\n\n### 논리 연산자(Logical Operator)\n\n| 논리 연산자 |                               설명                               |\n|:-----------:|:----------------------------------------------------------------:|\n|      &&     |         논리식이 모두 참이면 1을 반환함. (논리 AND 연산)         |\n|      \\|\\|     |     논리식 중에서 하나라도 참이면 1을 반환함. (논리 OR 연산)     |\n|      !      | 논리식의 결과가 참이면 0을, 거짓이면 1을 반환함. (논리 NOT 연산) |\n\n> 예제\n> ``` cpp\n> int num1 = 3;\n> \n> int num2 = -7;\n> \n> bool result1, result2;\n> \n>  \n> \n> result1 = (num1 > 0) && (num1 < 5);\n> \n> result2 = (num2 < 0) || (num2 > 10);\n> \n>  \n> \n> cout << \"&& 연산자에 의한 결괏값은 \" << result1 << \"입니다.\" << endl;\n> // && 연산자에 의한 결괏값은 1입니다.\n> \n> cout << \"|| 연산자에 의한 결괏값은 \" << result2 << \"입니다.\" << endl;\n> // || 연산자에 의한 결괏값은 1입니다.\n> \n> cout << \" ! 연산자에 의한 결괏값은 \" << !result2 << \"입니다.\" << endl;\n> // ! 연산자에 의한 결괏값은 0입니다.\n> ```\n\n### 삼항 연산자(Ternary Operator)\n\n> 문법\n> ``` cpp\n> 조건식 ? 반환값1(True) : 반환값2(False)\n> \n> ```\n\n물음표(?) 앞의 조건식에 따라 결괏값이 참(true)이면 반환값1을 반환하고, 결괏값이 거짓(false)이면 반환값2를 반환합니다.\n\n조건문과 같은 방식으로 쓰이며 이를 다음과 같이 조건문으로 바꾸어 쓸 수도 있지만, 조건문에 대한 자세한 내용은 후술하도록 하겠습니다.\n\n> ``` cpp\n> if (조건식)\n> \n> {\n>     반환값1(True)\n> }\n> \n> else\n> {\n>     반환값2(False)\n> }\n> ```","excerpt":"연산자(Operator) C++은 여러 종류의 연산을 위해 다양한 연산자(operator)를 제공하고 있습니다.  산술연산자(Arithmetic Operator…","fields":{"slug":"/cpp06/"},"frontmatter":{"date":"Feb 27, 2020","title":"바닥에서 시작하는 C++ (6) - 연산자(Operator)","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 상수\n\n상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미합니다.\n\n하지만 상수가 변수와 다른 점은 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다는 점입니다.\n\nC++에서 상수는 표현 방식에 따라 다음과 같이 나눌 수 있습니다.\n\n \n\n1. 리터럴 상수(literal constant)\n\n2. 심볼릭 상수(symbolic constant)\n\n## 리터럴 상수\n\n리터럴(Literal)은 변수에 넣는 변하지 않는 데이터를 말합니다.\n> ``` cpp\n> a = 5;\n> ```\n\n이 코드에서 5는 리터럴 상수입니다.\n\n리터럴 상수는 정수, 부동 소수점, 문자, 문자열, Boolean, 포인터 및 사용자가 정의한 리터럴로 분류 할 수 있습니다.\n\n### 정수 숫자\n> ``` cpp\n> 231\n>\n> 5542\n>\n> -43\n> ```\n\n정숫값을 식별하는 숫자 상수입니다. 인용 부호나 다른 특수 문자로 묶여 있지 않습니다.\n\n231은 문자 그대로 항상 231이라는 수 자체를 나타냅니다.\n\n\n### 부동 소수점 숫자\n\n소수점과 지수로 실제 값을 표현합니다.\n\n> ``` cpp\n> 3.14159    // 3.14159\n>\n> 6.02e23    // 6.02 x 10^23\n>\n> 1.6e-19    // 1.6 x 10^-19\n>\n> 3.0        // 3.0\n> ```\n\n### 문자 및 문자열 리터럴\n\n문자 및 문자열 리터럴은 따옴표로 묶습니다.\n\n> ``` cpp\n> 'z'\n> \n> 'q'\n> \n> \"Hello world\"\n> \n> \"KHU Software Convergence\"\n> \n> ```\n\n처음 두 표현식은 단일 문자 리터럴을 나타내고, 다음 두 표현식은 여러 문자로 구성된 문자열 리터럴을 나타냅니다.\n\n단일 문자를 나타내려면 작은 따옴표(`'`)로 묶고 문자열을 나타내려면 큰따옴표(`\"`)로 문자를 묶습니다.\n\n### 그 외의 리터럴\n\nC++에는 세 가지 키워드 리터럴(true, false, nullptr)이 있습니다.\n\n- bool 유형의 변수에는 true와 false만 사용이 가능합니다.\n- nullptr은 null 포인터 값 입니다.\n\n## 상수 표현식\n\n다음처럼 `const`를 사용하여 상수를 정의할 수도 있습니다.\n\n``` cpp\nconst double pi = 3.1415926;\n\nconst char tab = '\\t';\n```\n\n## 전처리기 정의 (#define)\n\n> ``` cpp\n> #define PI 3.14159\n> \n> #define NEWLINE '\\n'\n> ```\n\n**\\#define은 전 처리기 지시문이며, 끝에 세미콜론(`;`)이 필요하지 않습니다.**","excerpt":"상수 상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미합니다. 하지만 상수가 변수와 다른 점은 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다는 점입니다. C…","fields":{"slug":"/cpp05/"},"frontmatter":{"date":"Feb 23, 2020","title":"바닥부터 시작하는 C++ (5) - 상수","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 변수(Variable)\n\n변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미합니다.\n\n즉, 변수란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하며, 이렇게 저장된 값은 변경될 수 있습니다.\n\n \n\nC++에서 숫자 표현에 관련된 변수는 정수형 변수와 실수형 변수로 구분할 수 있습니다.\n\n또다시 정수형 변수는 char형, int형, long형, long long형 변수로, 실수형 변수는 float형, double형 변수로 구분됩니다.\n\n## 변수의 이름 생성 규칙\n\nC++에서는 변수의 이름을 비교적 자유롭게 지을 수 있습니다.\n\n변수의 이름은 해당 변수에 저장될 데이터의 의미를 잘 나타내도록 짓는 것이 좋습니다.\n\n \n\nC++에서 변수의 이름을 생성할 때 반드시 지켜야 하는 규칙은 다음과 같습니다.\n\n \n1. 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성됩니다.\n\n2. 변수의 이름은 숫자로 시작될 수 없습니다.\n\n3. 변수의 이름 사이에는 공백을 포함할 수 없습니다.\n\n4. 변수의 이름으로 C++에서 미리 정의된 키워드(keyword)는 사용할 수 없습니다.\n\n5. 변수 이름의 길이에는 제한이 없습니다.\n\n**C++은 변수의 이름에 대소문자를 구분합니다!**\n\n## 변수와 메모리 주소\n\n변수는 기본적으로 메모리의 주소(address)를 기억하는 역할을 합니다.\n\n메모리 주소란 물리적인 메모리 공간을 서로 구분하기 위해 사용되는 일종의 식별자입니다.\n\n즉, 메모리 주소란 메모리 공간에서의 정확한 위치를 식별하기 위한 고유 주소를 의미합니다.\n\n \n\n변수를 참조할 때는 메모리의 주소를 참조하는 것이 아닌, 해당 주소에 저장된 데이터를 참조하게 됩니다.\n\n따라서 변수는 데이터가 저장된 메모리의 주소뿐만 아니라, 저장된 데이터의 길이와 형태에 관한 정보도 같이 기억해야 합니다.\n\n \n\n다음 그림은 메모리상에 변수가 어떤 식으로 저장되는지를 보여줍니다.\n\n![변수 저장 방법](1.png)\n\n이 내용은 포인터의 개념을 이해하기 위해 필요한 개념이므로 익혀두는 것이 좋습니다.\n\n## 변수의 선언\n\nC++에서는 변수를 사용하기 전에 반드시 먼저 해당 변수를 저장하기 위한 메모리 공간을 할당받아야 합니다.\n\n이렇게 해당 변수만을 위한 메모리 공간을 할당받는 행위를 변수의 선언이라고 부릅니다.\n\n \n\nC++에서 변수를 선언하는 방법에는 다음과 같이 두 가지 방법이 있습니다.\n\n \n\n1. 변수의 선언만 하는 방법\n\n2. 변수의 선언과 동시에 초기화하는 방법\n\n### 변수의 선언만 하는 방법\n\n이 방법은 먼저 변수를 선언하여 메모리 공간을 할당받고, 나중에 변수를 초기화하는 방법입니다.\n\n하지만 이렇게 선언만 된 변수는 초기화하지 않았기 때문에 해당 메모리 공간에는 알 수 없는 쓰레깃값만이 들어가 있습니다.\n\n따라서 초기화하지 않은 변수는 절대로 사용해서는 안 됩니다.\n> 문법\n> ``` cpp\n> 타입 변수이름;\n> ```\n\n다음의 예제와 같이 먼저 변수를 선언해둔 뒤 나중에 초기화해줄 수 있습니다.\n\n> 예제\n> ``` cpp\n> int num;\n> \n> ...\n> \n> num = 20;\n> ```\n\n\n### 변수의 선언과 동시에 초기화하는 방법\n\nC++에서는 변수의 선언과 동시에 그 값을 초기화할 수 있습니다.\n\n또한, 선언하고자 하는 변수들의 타입이 같다면 이를 동시에 선언할 수 있습니다.\n\n> 문법\n> ``` cpp\n> \n> 타입 변수이름[, 변수이름];\n> \n> 타입 변수이름 = 초깃값[, 변수이름 = 초깃값];\n> \n> ```\n\n> 예제\n> ``` cpp\n> int num1, num2;\n> \n> double num3 = 1.23, num4 = 4.56;\n> ```\n","excerpt":"변수(Variable) 변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미합니다. 즉, 변수란 데이터(data…","fields":{"slug":"/cpp04/"},"frontmatter":{"date":"Feb 20, 2020","title":"바닥부터 시작하는 C++ (4) - 변수","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## iostream(Input/Output Stream)\n\n사용자가 프로그램과 대화하기 위해서는 사용자와 프로그램 사이의 입출력을 담당하는 수단이 필요합니다.\n\nC++의 모든 것은 객체로 표현되므로, 입출력을 담당하는 수단 또한 C언어의 함수와는 달리 모두 객체입니다.\n\n \n\nC언어의 printf() 함수나 scanf() 함수처럼 C++에서도 **iostream 헤더 파일에 표준 입출력 클래스를 정의**하고 있습니다.\n\nC++에서는 **cout 객체로 출력** 작업을, **cin 객체로 입력** 작업을 수행하고 있습니다.\n\n \n\n또한, C++에서는 기존의 C언어 스타일처럼 printf() 함수나 scanf() 함수로도 입출력 작업을 수행할 수 있습니다.\n\n## cout 객체\n\ncout 객체는 다양한 데이터를 출력하는 데 사용되는 C++에서 미리 정의된 출력 스트림을 나타내는 객체입니다.\n\ncout 객체를 사용하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> std::cout << 출력할 데이터;\n> ```\n\n삽입 연산자(<<)는 오른쪽에 위치한 출력할 데이터를 출력 스트림에 삽입합니다.\n\n이렇게 출력 스트림에 삽입된 데이터는 스트림을 통해 출력 장치로 전달되어 출력됩니다.\n\n``` cpp\ncout << \"Hello World!\"; // Hello World!\n```\n\n## cin 객체\n\ncin 객체는 다양한 데이터를 입력받는 데 사용되는 C++에서 미리 정의된 입력 스트림을 나타내는 객체입니다.\n\ncin 객체를 사용하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> std::cin >> 저장할 변수;\n> ```\n추출 연산자(>>)를 통해 사용자가 입력한 데이터를 입력 스트림에서 추출하여, 오른쪽에 위치한 변수에 저장합니다.\n\n이때 cin 객체는 자동으로 사용자가 입력한 데이터를 오른쪽에 위치한 변수의 타입과 동일하게 변환시켜 줍니다.\n\n**주의 : cout과 cin의 화살표 방향이 서로 다릅니다!**\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> using namespace std;\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     int age;\n> \n>  \n> \n>     cout << \"나이를 입력해 주세요 : \";\n> \n>     cin >> age;\n> \n>  \n> \n>     cout << age << \"살 입니다.\" << endl;\n> \n>     return 0;\n> \n> }\n> ```\n\n위의 예제에서 여러분이 입력한 데이터는 자동으로 정수를 저장할 때 사용하는 타입으로 변환될 것입니다.\n\n만약에 문자열을 입력하면 cin 객체는 변수 age에 숫자가 아니라는 의미인 0을 전달할 것입니다.\n\n## C언어 표준 입출력 함수와의 차이점\n\nC언어 표준 입출력 함수인 printf() 함수나 scanf() 함수와 C++ 표준 입출력 객체와의 차이점은 다음과 같습니다.\n\n \n\n1. 삽입 연산자(<<)와 추출 연산자(>>)가 데이터의 흐름을 나타내므로 좀 더 직관적입니다.\n\n2. C++ 표준 입출력 객체는 입출력 데이터의 타입을 자동으로 변환시켜주므로 더욱 편리하고 안전합니다.\n\n","excerpt":"iostream(Input/Output Stream) 사용자가 프로그램과 대화하기 위해서는 사용자와 프로그램 사이의 입출력을 담당하는 수단이 필요합니다. C++의 모든 것은 객체로 표현되므로, 입출력을 담당하는 수단 또한 C…","fields":{"slug":"/cpp03/"},"frontmatter":{"date":"Feb 18, 2020","title":"바닥부터 시작하는 C++ (3) - iostream","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 네임스페이스(Namespace)\n\n네임스페이스란 이름이 기억되는 영역을 뜻하며, 이름이 소속된 공간을 의미합니다.\n\n네임스페이스는 C++ 프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해 주는 방법을 제공합니다.\n\n이러한 네임스페이스는 C언어에는 없는 C++ 만의 새로운 기능입니다.\n\n \n\nC++ 프로그램의 표준 구성 요소인 클래스, 함수, 변수 등은 std라는 이름 공간에 저장되어 있습니다.\n\n따라서 C++ 프로그램에서 표준 헤더 파일인 iostream 내의 정의를 사용하려면 다음과 같이 사용해야 합니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     std::cout << TEXT;\n> \n>     return 0;\n> \n> }\n> ```\n\n위의 예제처럼 std라는 네임스페이스에 있는 정의를 사용하려면, std:: 접두어를 붙여 해당 정의가 std라는 네임스페이스에 있다는 것을 컴파일러에 알려줘야 합니다.\n\n \n\n이러한 네임스페이스에 속한 정의를 간단하게 사용하려면 다음과 같은 명령문을 추가하면 됩니다.\n\n> ``` cpp\n> using namespace std; // std라는 네임스페이스에 속한 정의들은 네임스페이스 이름을 붙이지 않아도 사용할 수 있음.\n> ```\n\n다음 예제는 앞서 살펴본 예제와 정확히 같은 동작을 수행합니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n> using namespace std;\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     cout << TEXT;\n> \n>     return 0;\n> \n> }\n> ```\n\n## 주석\n\n주석이란 코드에 대한 이해를 돕는 설명을 적거나 디버깅을 위해 작성하는 일종의 메모입니다.\n\nC++ 컴파일러는 주석은 무시하고 컴파일하므로, 실행 파일에서는 이러한 주석을 확인할 수 없습니다.\n\n \n\nC++에서 주석을 작성하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> // 한 줄 주석\n> \n> /*\n> \n> 여러 줄 주석\n> \n> */\n> ```\n\nC++에서는 여러 줄 주석 안에 또 다른 한 줄 주석을 삽입할 수 있습니다.\n하지만 여러 줄 주석 안에 또 다른 여러 줄 주석은 중첩해서 삽입할 수는 없습니다.\n\n> ``` cpp\n> /*\n> \n> 여러 줄 주석\n> \n> //한 줄 주석 삽입 가능!\n>\n> */\n>\n> \n> /*\n> \n> 여러 줄 주석\n> \n> /*여러 줄 주석 삽입 불가*/\n>\n> */\n>\n> ```\n\n위의 예제 마지막 줄 */는 주석으로 처리되지 않은 것을 확인할 수 있습니다.","excerpt":"네임스페이스(Namespace) 네임스페이스란 이름이 기억되는 영역을 뜻하며, 이름이 소속된 공간을 의미합니다. 네임스페이스는 C++ 프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해 주는 방법을 제공합니다. 이러한 네임스페이스는 C…","fields":{"slug":"/cpp02/"},"frontmatter":{"date":"Feb 16, 2020","title":"바닥부터 시작하는 C++ (2) - 네임스페이스, 주석","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## C++의 특징\n\nC++이 프로그래밍 언어로써 가지는 특징은 다음과 같습니다.\n\n \n\n1. C++은 절차 지향적이며 구조적 프로그래밍 언어입니다.\n\n2. C++은 객체 지향 프로그래밍 언어입니다.\n\n3. C++은 일반화 프로그래밍 언어입니다.\n\n \n\n이처럼 C++은 세 가지 프로그래밍 방식을 모두 지원하는 언어이며, 따라서 다양한 방식으로 프로그램을 작성할 수 있습니다.\n\n또한, 다양한 시스템에서의 프로그래밍을 지원하는 유용하고도 강력한 클래스 라이브러리들이 아주 많이 제공됩니다.\n\n\n## 실행 파일 생성 과정\n\n![실행 파일 생성 과정](1.png)\n\n1. 소스 파일(source file)의 작성\n\n2. 선행처리기(preprocessor)에 의한 선행처리\n\n3. 컴파일러(compiler)에 의한 컴파일\n\n4. 링커(linker)에 의한 링크\n\n5. 실행 파일(executable file)의 생성\n\n## 기본 구조\n\n간단한 C++ 프로그램의 기본 구조는 다음과 같습니다.\n\n언제나 다음과 같이 구성되는 것은 아니지만 많은 C++ 프로그램이 이와 비슷한 형태로 구성됩니다.\n\n> 문법\n> ``` cpp\n> #include 문\n> \n> #define 문\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     명령문;\n> \n>     return 문;\n> \n> }\n> ```\n\n간단한 텍스트를 출력하는 예제는 다음과 같습니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     std::cout << TEXT; // Welcome to C++ Programming!!\n> \n>     return 0;\n> \n> }\n> ```\n\n### main() 함수\n\nC++ 프로그램은 가장 먼저 main() 함수를 찾고, 그곳에서부터 실행을 시작합니다.\n\n따라서 모든 C++ 프로그램은 반드시 하나의 main() 함수를 가지고 있어야 합니다.\n\n만약 main() 함수를 발견하지 못하면 C++ 컴파일러는 오류를 발생시킬 것입니다.\n\n### 명령문(Statement)\n\nC++ 프로그램의 동작을 명시하고, 이러한 동작을 컴퓨터에 알려주는 데 사용되는 문장을 명령문(statement)이라고 합니다.\n\n이러한 C++의 모든 명령문은 반드시 세미콜론(;)으로 끝나야 합니다.\n\n> ``` cpp\n> std::cout << \"C++ 프로그래밍\"; // 정상적으로 출력됨.\n> \n> std::cout << \"C++ 프로그래밍\"  // 오류가 발생함.\n> \n> ```\n\n### 반환문(Return)\n\n반환문은 함수의 종료를 의미하며, 함수를 호출한 곳으로 결괏값을 반환하는 역할을 합니다.\n\n특히 main() 함수가 반환되면, 프로그램 전체가 종료됩니다.\n\n### 선행처리문(Preprocess)\n\n\\#include 문과 #define 문은 모두 선행처리기에 의해 처리되는 선행처리문입니다.\n\n \n\n\\#include 문은 외부에 선언된 함수나 상수 등을 사용하기 위해서 헤더 파일의 내용을 현재 파일에 포함할 때 사용합니다.\n\nC언어에서는 헤더 파일에 .h 확장자를 사용했지만, C++에서는 헤더 파일의 확장자를 사용하지 않기로 합니다.\n\n따라서 기존 C언어 헤더 파일들의 이름 앞에 c를 추가하여 C++ 스타일의 헤더 파일로 변환하기도 합니다.\n> ``` cpp\n> #include <math.h> // C, C++ 모두 허용\n> \n> #include <cmath>  // C++에서만 허용\n> ```\n\n물론 원칙은 위와 같이 바뀌었지만 C++ 프로그램에서는 기존의 C언어 스타일로도 헤더 파일을 사용할 수 있습니다.\n\n\\#define 문은 함수나 상수를 단순화해주는 매크로를 정의할 때 사용합니다.","excerpt":"C++의 특징 C++이 프로그래밍 언어로써 가지는 특징은 다음과 같습니다. C++은 절차 지향적이며 구조적 프로그래밍 언어입니다. C++은 객체 지향 프로그래밍 언어입니다. C++은 일반화 프로그래밍 언어입니다. 이처럼 C…","fields":{"slug":"/cpp01/"},"frontmatter":{"date":"Feb 14, 2020","title":"바닥부터 시작하는 C++ (1) - 기본 특징","tags":["C++"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}