{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## 카카오톡 봇\n\n게임 캐릭터 정보를 확인하기 위해 따로 인터넷 검색을 해야 하는 번거로운 작업을 줄이고, 간단한 편의성 기능을 제공하기 위해 개인적으로 사용할 목적의 카카오톡 봇을 만들어보기로 결심했습니다.\n\n봇 최초 컴파일(3월 7일) 이후 2주가 지난 지금, 어느정도 봇도 안정화되었고 개발 과정에 대해 궁금해하시는 분들이 있어서 개발 과정을 간단하게 공개해보려 합니다.\n\n### 작동 원리\n\n지금까지 카카오톡 단체 채팅방이나 오픈 톡방에서 방장봇을 제외한 사설 봇을 보았다면, 아마 99.9% 모두 같은 원리로 동작하는 봇들입니다.\n\n한 때 카카오톡의 통신 프로토콜인 `LOCO Protocol`(2011년 10월 13일 릴리즈, 기존 HTTP/TCP 프로토콜에서 자체 개발한 LOCO 프로토콜로 변경)을 통해 카카오톡 클라이언트인 척 메시지를 보내는 봇들도 있었으나, 해당 부분은 보안에 취약하기도 하고 약관에 위배되기 때문에 해당 방법을 이용한 봇들을 사용하면 계정이 정지당할 수 있습니다.\n\n이 때문에 현재 카카오톡 봇 앱을 통해 구동되는 봇들이 대부분이라고 볼 수 있습니다.\n\n봇 구동을 위해 많이 사용하는 앱은 `메신저봇 R`, `채팅 자동응답 봇`입니다. 제가 사용한 앱은 `메신저봇 R`이며, 앞으로의 설명들은 모두 해당 앱을 기준으로 진행됩니다.\n\n![메신저봇 R](https://play-lh.googleusercontent.com/I5QjPGUfiYmHcMqmKdIPj7AOIIADGsMcSV_eibFPUxjPUDq1R_7cDycJ7kevpi862w=s360-rw)\n\n해당 앱의 작동 원리는 아래와 같습니다.\n\n1. `NotificationListenerService`를 통해 알림을 파싱한다.\n2. Rhino JavaScript Engine을 사용하여 사용자가 작성한 자바스크립트로 알림 정보를 전달하여 처리한다.\n3. `WearableExtender`를 통해 답장을 전달한다.\n\n1번에서 받게 되는 알림의 내용에는 채팅이 온 방의 이름, 메시지 내용, 전송자의 이름 등의 정보가 있습니다.\n\n해당 정보들을 받으면 2번 과정에서 사용자가 작성한 자바스크립트의 내용에 따라 정보를 처리하게 됩니다. (인터넷에서 해당 정보를 찾아온다던가, 결과값을 더 예쁘게 보일 수 있도록 처리)\n\n그리고 해당 결과를 다시 채팅방에 reply 해주면서 챗봇이 동작하게 됩니다.\n\n\n### 준비물\n\n애석하게도, 현재 카카오톡의 정책 때문에 준비할것이 조금 있습니다.\n\n저는 공기계(갤럭시 S9+ 기기)를 통해 봇을 동작시킬것이기 때문에, 하나의 본계정을 두개의 기기에 모두 로그인해서 사용할 수 없는 카카오톡의 정책 상 부계정을 하나 새로 만들었습니다.\n\n(공기계가 아닌 본인의 기기로 본계정을 통해 봇을 구동할 경우, 사용자의 도배나 악용으로 인해 제재를 받는 경우 대처하기가 어려워집니다.)\n\n부계정을 만드는 방법에는 크게 두 가지 정도가 있습니다.\n\n1. 통신사의 투넘버 서비스(번호 두개 이용)를 통해 계정을 하나 더 생성한다.\n2. 가상 해외 번호를 통해 계정을 하나 더 생성한다.\n\n두 방법은 장단점이 있습니다. 1번 방식은 통신사에 추가 비용을 지불해야 한다는 단점이 있으며, 카카오톡 임시조치 제한을 받지 않는다는 장점이 있습니다(계정 바로 이용 가능)\n하지만, 2번 방식은 앱을 통해 가상 해외 번호를 받아서 카카오톡 인증만 진행하면 되기 때문에 추가 비용이 들지 않는다는 장점이 있습니다. 하지만, 카카오톡의 정책으로 인한 임시조치 제한을 받습니다.\n\n여기서 임시조치 제한이란?\n```\n1) 짧은 기간 다수의 사용자가 카카오톡 친구로 추가되는 경우\n\n2) 서비스 악용 유저가 활동한 서비스 환경과 유사한 환경에서 서비스를 사용한 경우\n\n3) 불법 사행성 사이트 홍보 및 음란물 발송 이력이 있는 서비스 이용 환경에서 카카오톡을 사용한 경우\n\n4) 짧은 기간 동안 채팅방 및 오픈 채팅방을 다수 개설한 경우\n\n5) 오픈 채팅방 참여 속도 및 빈도가 비정상적으로 많을 경우\n\n6) 통신사 확인이 되지 않는 해외 가상번호를 사용하는 경우\n\n7) 메시지 신고 접수가 많이 된 경우\n\n8) 오픈 채팅방 사용자 신고 접수가 증가할 경우\n\n9) PC 에뮬레이터 등 비정상적인 환경에서 카카오톡을 사용할 경우 \n```\n해당 사례 중 한 가지, 혹은 두 가지 이상 해당되었을 때 적용되는 보호조치로, 오픈채팅을 이용하지 못하며 친구추가 수에 제한이 걸리게 됩니다.\n\n물론 임시로 적용되는 제한이기 때문에 일정 기간 정상적으로 카카오톡을 이용하는 것이 카카오톡 내부 매커니즘(봇에 의해 자동으로 이루어지는 것으로 추정)에 의해 확인이 된다면 해제되긴 합니다만, 언제 풀릴지는 정확히 알 수 없습니다.\n\n가상 해외 번호를 통해 인증한 경우 거의 무조건 임시조치 제한에 걸리게 되니 참고해주세요.(6번 내용에 해당)\n\n저는 급한 프로젝트가 아니었으므로 해외 번호로 가입 후 제한이 풀리기를 기다렸습니다.\n","excerpt":"카카오톡 봇 게임 캐릭터 정보를 확인하기 위해 따로 인터넷 검색을 해야 하는 번거로운 작업을 줄이고, 간단한 편의성 기능을 제공하기 위해 개인적으로 사용할 목적의 카카오톡 봇을 만들어보기로 결심했습니다. 봇 최초 컴파일(3월 7일) 이후…","fields":{"slug":"/KakaoBot_1/"},"frontmatter":{"date":"Mar 22, 2022","title":"카카오톡 봇 제작기 (1) - 구동 원리, 준비물","tags":["Bot","KakaoTalk"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## LSTM(Long Short Term Memory) 실습\n\nKaggle의 영화 리뷰에 대한 감정 예측 데이터셋에 대해 LSTM으로 자연어차리 실습을 해보도록 하겠습니다.\n\n[Kaggle 링크](https://www.kaggle.com/c/movie-review-sentiment-analysis-kernels-only/)를 통해 실습 데이터셋을 받을 수 있습니다.\n\nData 탭에서 `train.tsv.zip`, `test.tsv.zip` 을 내려받아 압축을 풀면 각각 train set과 test set의 tsv 파일을 얻을 수 있습니다.\n\n해당 데이터셋에서 감정을 나타내는 label들의 의미는 다음과 같습니다.\n\n- 0 : negative\n- 1 : somewhat negative\n- 2 : neutral\n- 3 : somewhat positive\n- 4 : positive\n\n### 데이터 가져오기\n\n우선 실습에 필요한 library들을 불러옵니다.\n\n```python\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nplt.style.use('dark_background')\nfrom keras.preprocessing.text import Tokenizer\nfrom keras.preprocessing.sequence import pad_sequences\nfrom sklearn.model_selection import train_test_split\nfrom keras.utils.np_utils import to_categorical\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Embedding, LSTM, GlobalMaxPooling1D, SpatialDropout1D\n```\n\n`to_categorical`은 keras의 버전에 따라 \n```python\nfrom keras.utils.np_utils import to_categorical\n```\n혹은\n```python\nfrom keras.utils import to_categorical\n```\n\n둘 중 동작하는 것으로 진행하면 됩니다.\n\n```python\ndf_train = pd.read_csv('train.tsv', sep='\\t')\nprint('train set: {0}'.format(df_train.shape))\ndf_train.head(10)\n```\n\n우선 train 데이터셋을 불러왔습니다. tsv 파일이므로 `sep='\\t'`옵션으로 데이터를 불러옵니다.\n\n\n```python\ndf_test = pd.read_csv('test.tsv', sep='\\t')\nprint('test set: {0}'.format(df_test.shape))\ndf_test.head(10)\n```\n\n마찬가지로, test 데이터셋도 불러와줍니다.\n\n### 데이터 전처리\n\n```python\nreplace_list = {r\"i'm\": 'i am',\n                r\"'re\": ' are',\n                r\"let’s\": 'let us',\n                r\"'s\":  ' is',\n                r\"'ve\": ' have',\n                r\"can't\": 'can not',\n                r\"cannot\": 'can not',\n                r\"shan’t\": 'shall not',\n                r\"n't\": ' not',\n                r\"'d\": ' would',\n                r\"'ll\": ' will',\n                r\"'scuse\": 'excuse',\n                ',': ' ,',\n                '.': ' .',\n                '!': ' !',\n                '?': ' ?',\n                '\\s+': ' '}\ndef clean_text(text):\n    text = text.lower()\n    for s in replace_list:\n        text = text.replace(s, replace_list[s])\n    text = ' '.join(text.split())\n    return text\n\n```\n\n원활한 학습을 위해 전처리를 진행해줍니다. `i'm` 과 `i am`은 같은 단어이지만 다르게 인식될 수 있으므로 형태를 통일해주고, 단어 뒤에 문장 부호가 붙어있는 경우에도 다른 단어로 인식되므로 빈 칸을 추가하여 단어와 문장 부호가 서로 다른 단어로 인식될 수 있게끔 전처리를 해줍니다. 또한, 대문자와 소문자의 차이도 제거하기 위해 모든 단어의 글자들을 `.lower()`함수를 통해 소문자로 만들어 줍니다.\n\n아래 코드를 통해 적용해줍니다.\n\n```python\nX_train = df_train['Phrase'].apply(lambda p: clean_text(p))\n```\n\n<br/>\n이제, corpus(말뭉치)에 있는 구문의 길이를 시각화해보겠습니다.\n\n```python\nphrase_len = X_train.apply(lambda p: len(p.split(' ')))\nmax_phrase_len = phrase_len.max()\nprint('max phrase len: {0}'.format(max_phrase_len))\nplt.figure(figsize = (10, 8))\nplt.hist(phrase_len, alpha = 0.2, density = True)\nplt.xlabel('phrase len')\nplt.ylabel('probability')\nplt.grid(alpha = 0.25)\n```\n```\nmax phrase len: 53\n```\n![](1.png)\n\n가장 긴 문장의 길이는 53이며, 단어 길이의 분포는 위와 같습니다.\n\n신경망에 대한 모든 입력은 길이가 같아야합니다. 따라서 가장 긴 길이를 나중에 모델에 대한 입력을 정의하는 데 사용할 변수로 저장합니다.\n\n```\ny_train = df_train['Sentiment']\n```\n\n감정 데이터가 있는 `Sentiment` 항목으로 train set을 만들어줍니다.\n\n이제 `tokenizer`를 통해 토큰화를 진행합니다. \n또한, `filters=` 옵션을 통해 특수문자들을 제거해줍니다.\n\n```\nmax_words = 8192\ntokenizer = Tokenizer(\n    num_words = max_words,\n    filters = '\"#$%&()*+-/:;<=>@[\\]^_`{|}~'\n)\ntokenizer.fit_on_texts(X_train)\nX_train = tokenizer.texts_to_sequences(X_train)\nX_train = pad_sequences(X_train, maxlen = max_phrase_len)\ny_train = to_categorical(y_train)\n```\n\n`to_categorical` 함수를 통해, `y_train` 값을 원-핫 벡터로 바꿔주어 인코딩 과정도 진행해줍니다.\n\n### Training\n\n```python\nmodel_lstm = Sequential()\nmodel_lstm.add(Embedding(input_dim = max_words, output_dim = 256, input_length = max_phrase_len))\nmodel_lstm.add(SpatialDropout1D(0.3))\nmodel_lstm.add(LSTM(256, dropout = 0.3, recurrent_dropout = 0.3))\nmodel_lstm.add(Dense(256, activation = 'relu'))\nmodel_lstm.add(Dropout(0.3))\nmodel_lstm.add(Dense(5, activation = 'softmax'))\nmodel_lstm.compile(\n    loss='categorical_crossentropy',\n    optimizer='Adam',\n    metrics=['accuracy']\n)\n```\nLSTM 레이어를 만들어 모델을 작성합니다.\n\n```python\nhistory = model_lstm.fit(\n    X_train,\n    y_train,\n    validation_split = 0.1,\n    epochs = 8,\n    batch_size = 512\n)\n```\n`epochs`는 8, `batch_size`는 512로 설정하고 10%만큼을 validation set으로 이용하게 됩니다.\n\n![](2.png)\n\ntrain이 완료되었습니다. history에는 LSTM fitting 과정에서 각 epoch마다의 `loss`와 `accuracy` 데이터가 저장됩니다.\n\nloss와 accuracy 데이터를 시각화하면 다음과 같습니다.\n\n```python\nplt.clf()\nloss = history.history['loss']\nval_loss = history.history['val_loss']\nepochs = range(1, len(loss) + 1)\nplt.figure(figsize=(10, 8))\nplt.plot(epochs, loss, 'g', label='Training loss')\nplt.plot(epochs, val_loss, 'y', label='Validation loss')\nplt.title('Training and validation loss')\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.legend()\nplt.show()\n```\n\n![](3.png)\n\n```python\nplt.clf()\nacc = history.history['accuracy']\nval_acc = history.history['val_accuracy']\nplt.figure(figsize=(10, 8))\nplt.plot(epochs, acc, 'g', label='Training acc')\nplt.plot(epochs, val_acc, 'y', label='Validation acc')\nplt.title('Training and validation accuracy')\nplt.xlabel('Epochs')\nplt.ylabel('Accuracy')\nplt.legend()\nplt.show()\n```\n\n![](4.png)","excerpt":"LSTM(Long Short Term Memory) 실습 Kaggle의 영화 리뷰에 대한 감정 예측 데이터셋에 대해 LSTM으로 자연어차리 실습을 해보도록 하겠습니다. Kaggle 링크를 통해 실습 데이터셋을 받을 수 있습니다. Data…","fields":{"slug":"/LSTM/"},"frontmatter":{"date":"Jun 07, 2021","title":"자연어 처리(NLP) 실습 - LSTM","tags":["ML"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Word2Vec 실습(EN)\n\n영어 데이터를 통해 Word2Vec을 학습시켜보도록 하겠습니다. `gensim`이라는 파이썬 패키지에 Word2Vec이 이미 구현되어 있으므로, 우리는 이를 따로 구현할 필요 없이 Word2Vec을 사용할 수 있습니다.\n\n우선 필요한 도구들을 import해주겠습니다.\n\n```python\nimport nltk\nnltk.download('punkt')\n```\n\n```python\nimport urllib.request\nimport zipfile\nfrom lxml import etree\nimport re\nfrom nltk.tokenize import word_tokenize, sent_tokenize\n```\n\n### 훈련 데이터\n\n사용할 훈련 데이터는, ted 영상들의 자막 데이터입니다. 파일의 형식은 xml 파일입니다.\n\n[해당 링크](https://wit3.fbk.eu/get.php?path=XML_releases/xml/ted_en-20160408.zip&filename=ted_en-20160408.zip)를 통해 내려받고 압축을 풀어서 `ted_en-20160408.xml`라는 이름의 파일을 설치할 수도 있고, 파이썬 코드를 통해 자동으로 설치할 수도 있습니다. \n\n```python\n# 데이터 다운로드\nurllib.request.urlretrieve(\"https://raw.githubusercontent.com/GaoleMeng/RNN-and-FFNN-textClassification/master/ted_en-20160408.xml\", filename=\"ted_en-20160408.xml\")\n```\n<br/>\n위의 코드를 통해 xml 파일을 내려받으면, 다음과 같은 파일을 볼 수 있습니다.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<xml language=\"en\"><file id=\"1\">\n  <head>\n    <url>http://www.ted.com/talks/knut_haanaes_two_reasons_companies_fail_and_how_to_avoid_them</url>\n\n    ...\n\n    <content>Here are two reasons companies fail: they only do more of the same, or they only do what's new.\n\n    ...\n\n    So let me leave you with this. Whether you're an explorer by nature or whether you tend to exploit what you already know, don't forget: the beauty is in the balance.\n    Thank you.\n    (Applause)</content>\n</file>\n<file id=\"2\">\n  <head>\n    <url>http://www.ted.com/talks/lisa_nip_how_humans_could_evolve_to_survive_in_space</url>\n    \n    ...\n\n    (Applause)</content>\n</file>\n</xml>\n\n```\n\n### 전처리\n\n```python\ntargetXML=open('ted_en-20160408.xml', 'r', encoding='UTF8')\n# xml 파일과 python 실행 위치가 같은 경로일 경우의 코드!\ntarget_text = etree.parse(targetXML)\nparse_text = '\\n'.join(target_text.xpath('//content/text()'))\n# xml 파일로부터 <content>와 </content> 사이의 내용만 가져온다.\n\ncontent_text = re.sub(r'\\([^)]*\\)', '', parse_text)\n# 정규 표현식의 sub 모듈을 통해 content 중간에 등장하는 (Audio), (Laughter) 등의 배경음 부분을 제거.\n# 해당 코드는 괄호로 구성된 내용을 제거.\n\nsent_text = sent_tokenize(content_text)\n# 입력 코퍼스에 대해서 NLTK를 이용하여 문장 토큰화를 수행.\n\nnormalized_text = []\nfor string in sent_text:\n     tokens = re.sub(r\"[^a-z0-9]+\", \" \", string.lower())\n     normalized_text.append(tokens)\n# 각 문장에 대해서 구두점을 제거하고, 대문자를 소문자로 변환.\n\nresult = []\nresult = [word_tokenize(sentence) for sentence in normalized_text]\n# 각 문장에 대해서 NLTK를 이용하여 단어 토큰화를 수행.\n```\n\n전처리 과정 후, 샘플의 수를 출력하면 다음과 같습니다.\n\n```python\nprint('총 샘플의 개수 : {}'.format(len(result)))\n```\n```\n총 샘플의 개수 : 273424\n```\n\n전처리가 되었으니, 이제 Word2Vec을 통해 텍스트 데이터를 학습시켜줍니다.\n\n### Word2Vec 학습\n\nWord2Vec 훈련에 앞서, gensim 모듈이 없다면 설치해줍니다.\n```\n$ pip install gensim\n```\n<br/>\n설치가 완료되었다면, 아래의 코드를 통해 아까 전처리한 데이터를 Word2Vec 모델로 학습시켜줍니다.\n\n```python\nfrom gensim.models import Word2Vec, KeyedVectors\nmodel = Word2Vec(sentences=result, vector_size=100, window=5, min_count=5, workers=4, sg=0)\n```\n\n여기서 Word2Vec의 하이퍼파라미터값은 다음과 같습니다.\n\n- **vector_size** = 워드 벡터의 특징 값. 즉, 임베딩 된 벡터의 차원.\n- **window** = 컨텍스트 윈도우 크기\n- **min_count** = 단어 최소 빈도 수 제한 (빈도가 적은 단어들은 학습하지 않는다.)\n- **workers** = 학습을 위한 프로세스 수\n- **sg** = 0은 CBOW, 1은 Skip-gram.\n\n\nWord2Vec에 대해서 학습을 진행하였습니다. Word2Vec는 입력한 단어에 대해서 가장 유사한 단어들을 출력하는 `model.wv.most_similar`을 지원합니다. \n\nearth와 유사한 단어는 어떤 것들이 있을까요?\n\n```python\nmodel_result = model.wv.most_similar(\"earth\")\nprint(model_result)\n```\n\n```\n[('planet', 0.8294868469238281), \n('mars', 0.7876790165901184), \n('surface', 0.683158278465271), \n('sun', 0.6683340072631836), \n('ocean', 0.6607442498207092), \n('moon', 0.6605572700500488), \n('continent', 0.6459723711013794), \n('universe', 0.6119515895843506), \n('galaxy', 0.6062458753585815), \n('orbit', 0.6049789786338806)]\n```\n\nearth와 유사한 단어로 planet, mars, surface, sun 등 정말 그럴싸한 단어들을 내놓는 것을 볼 수 있었습니다.\n\n### 모델 저장, 로드\n\n이렇게 학습시킨 Word2Vec 모델은 저장해두었다가 나중에 다시 로드해서 사용할 수 있습니다.\n\n```python\nmodel.wv.save_word2vec_format('./eng_w2v') # 모델 저장\nloaded_model = KeyedVectors.load_word2vec_format(\"eng_w2v\") # 모델 로드\n```\n<br/>\n\n위의 `loaded_model`은 앞선 예제의 `model.wv` 변수와 동일하게 사용하면 됩니다.\n\n```python\nmodel_result = loaded_model.most_similar(\"earth\")\nprint(model_result)\n```","excerpt":"Word2Vec 실습(EN) 영어 데이터를 통해 Word2Vec을 학습시켜보도록 하겠습니다. 이라는 파이썬 패키지에 Word2Vec이 이미 구현되어 있으므로, 우리는 이를 따로 구현할 필요 없이 Word2Vec…","fields":{"slug":"/Pytorch07/"},"frontmatter":{"date":"May 29, 2021","title":"자연어 처리(NLP)의 전처리 - Word2Vec(워드투벡터) 실습","tags":["Pytorch"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Word2Vec(워드투벡터)\n\n[원-핫 인코딩](https://mintyu.github.io/Pytorch04/)에서 언급했듯, 원-핫 벡터와 같은 희소 표현(Sparce Representation)은 단어 간 의미의 유사도를 표현할 수 없습니다.\n\n그래서 단어 간 의미의 유사도를 표현할 수 있도록 단어를 벡터화 할 수 있는 방법이 필요합니다.\n\n이 방법을 **분산 표현**(Distributed Representation)이라 합니다. 그리고, 이를 위해 사용되는 가장 대표적인 방식이 **Word2Vec**이라 할 수 있습니다. \n\n\n## 분산 표현(Distributed Representation)\n\n분산 표현(distributed representation) 방법은 기본적으로 분포 가설(distributional hypothesis)이라는 가정 하에 만들어진 표현 방법입니다. 이 가정은 **'비슷한 위치에서 등장하는 단어들은 비슷한 의미를 가진다'**라는 가정입니다.\n\n분산 표현은 분포 가설을 이용하여 단어들의 집합을 학습하고, 벡터에 단어의 의미를 여러 차원에 분산하여 표현합니다.\n\n분산 표현으로 벡터화하게 되면, 원-핫 벡터처럼 벡터의 차원이 단어 집합의 크기와 같지 않아도 됩니다. 이에 따라 벡터의 차원은 원-핫 벡터로 표현할 때보다 상대적으로 줄어들게 됩니다.\n\n분산 표현 학습 방법에는 NNLM, RNNLM 등이 있지만, 해당 방법들의 속도를 개선한 Word2Vec이 많이 쓰입니다.\n\n\n## CBOW(Continuous Bag of Words)\n\nWord2Vec에는 CBOW와 Skip-Gram 두 가지 방법이 있습니다. CBOW는 주변에 있는 단어들을 가지고 중간에 있는 단어들을 예측하는 방법이고, 반대로 Skip-Gram은 중간에 있는 단어로 주변 단어들을 예측하는 방법입니다. \n\nCBOW 방식의 예를 들면, 예문으로 `\"The fat cat sat on the mat\"`과 같은 문장이 있다고 할 때, `{\"The\", \"fat\", \"cat\", \"on\", \"the\", \"mat\"}`으로부터 sat을 예측해내는 것입니다. 이 때 예측해야하는 단어 sat을 중심 단어(center word)라고 하고, 예측에 사용되는 단어들을 주변 단어(context word)라고 합니다.\n\n중심 단어를 예측하기 위해서 앞, 뒤로 몇 개의 단어를 볼지를 결정했다면 이 범위를 윈도우(window)라고 합니다. 예를 들어서 윈도우 크기가 2이고, 예측하고자 하는 중심 단어가 sat이라고 한다면 앞의 두 단어인 fat와 cat, 그리고 뒤의 두 단어인 on, the를 참고합니다. 윈도우 크기가 n이라고 한다면, 실제 중심 단어를 예측하기 위해 참고하려고 하는 주변 단어의 개수는 2n이 될 것입니다.\n\n![](1.png)\n\n윈도우 크기를 정했다면, 윈도우를 계속 움직여서 주변 단어와 중심 단어 선택을 바꿔가며 학습을 위한 데이터 셋을 만들 수 있는데, 이 방법을 슬라이딩 윈도우(sliding window)라고 합니다.\n\n위 그림에서 좌측의 중심 단어와 주변 단어의 변화는 윈도우 크기가 2일때, 슬라이딩 윈도우가 어떤 식으로 이루어지면서 데이터 셋을 만드는지 보여줍니다. 또한 Word2Vec에서 입력은 모두 원-핫 벡터가 되어야 하는데, 우측 그림은 중심 단어와 주변 단어를 어떻게 선택했을 때에 따라서 각각 어떤 원-핫 벡터가 되는지를 보여줍니다. 위 그림은 결국 CBOW를 위한 전체 데이터 셋을 보여주는 것입니다.\n\n![](2.png)\n\n위는 크기가 $M$인 $v$벡터, 즉 투사층(Projection Layer)을 계산하는 과정입니다. 좌측의 입력층(Input Layer)에는 앞서 사용자가 정한 윈도우 크기 범위 내에 있는 주변 단어들의 원-핫 벡터들이 입력으로 주어지게 됩니다.\n\n이 입력값들에 크기가 $V \\times M$($V$: 입력에 사용된 원-핫 벡터의 크기, $M$: 투사층 벡터 $v$의 크기)인 가중치(Weight) 행렬 $W_{V \\times M}$을 각각 곱해서 모두 더한 뒤, 그 벡터에 window size에 2를 곱한 값을 나눈 벡터, 즉 평균인 $v$를 계산하게 됩니다. \n<br/>\n\n![](3.png)\n\n이렇게 구한 벡터는 두번째 가중치 행렬 $W^ \\prime _{M \\times V}$와 곱해지게 됩니다. 여기에서 나온 결과값은 입력층에서 입력으로 받은 원-핫 벡터의 크기와 같아집니다. \n\n이 벡터에 CBOW는 소프트맥스(softmax) 함수를 취하는데, 소프트맥스 함수로 인한 출력값은 0과 1사이의 실수로, 각 원소의 총 합은 1이 되는 상태로 바뀝니다. 이렇게 나온 벡터를 스코어 벡터(score vector)라고 합니다. 스코어 벡터의 각 차원 안에서의 값이 의미하는 것은 아래와 같습니다.\n\n스코어 벡터의 j번째 인덱스가 가진 0과 1사이의 값은 j번째 단어가 중심 단어일 확률을 나타냅니다. 그리고 이 스코어 벡터는 우리가 실제로 값을 알고있는 벡터인 중심 단어 원-핫 벡터의 값에 가까워져야 합니다.\n\n스코어 벡터를 $\\hat{y}$, 중심 단어를 $y$라고 했을 때, 이 두 벡터값의 오차를 줄이기위해 CBOW는 손실 함수(loss function)로 cross-entropy 함수를 사용합니다.\n\n$$\nH(\\hat{y}, y) = - \\sum_{j=1}^{\\left\\vert V \\right\\vert} y_j \\log(\\hat{y_i})\n$$\n\ncross-entropy 함수에 실제 중심 단어인 원-핫 벡터와 스코어 벡터를 입력값으로 넣은 수식은 위와 같습니다.\n\n$$\nH(\\hat{y}, y) = - y_i \\log(\\hat{y_i})\n$$\n\n중심 단어가 원-핫 벡터라는 것을 감안하면, 식을 위처럼 쓸 수도 있습니다. ($i$는 원-핫 벡터에서 0이 아닌 index)\n\n만약 정확하게 예측한 경우, $\\hat{y_i} = 1$ 이 되며, cross-entropy의 값은 $ -1 \\times \\log(1) = 0$ 이 됩니다. 따라서 해당 식을 최소화하는 방향으로 학습해야 합니다.\n\n이제 역전파(Back Propagation)를 수행하면 $W$와 $W^ \\prime$이 학습이 되는데, 학습이 다 되었다면 $M$차원의 크기를 갖는 $W$의 행이나 $W^ \\prime$의 열로부터 어떤 것을 임베딩 벡터로 사용할지를 결정하면 됩니다. 때로는 $W$와 $W^ \\prime$의 평균치를 가지고 임베딩 벡터를 선택하기도 합니다.\n\n## Skip-gram\n\nSkip-gram은 앞서 설명한 CBOW와 반대의 과정입니다. Skip-gram은 중심 단어를 보고, 어떤 주변 단어들이 올지 예측하기 위한 방법입니다.\n\n![](4.png)\n\n위 사진과 같은 과정으로 이루어지며, 중심 단어 하나에 대해서만 입력을 받기 때문에, CBOW처럼 평균을 구하는 과정은 없습니다. ","excerpt":"Word2Vec(워드투벡터) 원-핫 인코딩에서 언급했듯, 원-핫 벡터와 같은 희소 표현(Sparce Representation…","fields":{"slug":"/Pytorch06/"},"frontmatter":{"date":"May 12, 2021","title":"자연어 처리(NLP)의 전처리 - Word2Vec(워드투벡터)","tags":["Pytorch"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 희소 표현(Sparce Representation)\n\n희소 표현이란 데이터가 희소하다는 의미입니다. 여기서 데이터란 '우리가 관심을 갖는, 의미있는 정보'정도로 해석할 수 있을 것 같습니다.\n\n이해하기 쉽게 예를 들어 설명해봅시다.\n\n```\n[1, 0, 0, 0, 0, 0, 0, 0, 0]\n[0, 1, 0, 0, 0, 0, 0, 0, 0]\n[0, 0, 1, 0, 0, 0, 0, 0, 0]\n\n...\n\n```\n위의 벡터들은 희소 벡터라고 할 수 있습니다. 우리가 알고싶어 하는 정보의 인덱스만 1로 표현되고, 나머지 원소들은 0으로 이루어진 벡터입니다. 따라서 실제 표현하는 데이터의 양은 희소(Sparse)하며, 데이터를 표현하지 않는 나머지는 모두 0으로 표현됩니다.\n\n이와 같이 표현하는 것을 희소 표현이라고 합니다.\n\n지난 [원-핫 인코딩](https://mintyu.github.io/Pytorch04/) 게시물에서 배운 원-핫 인코딩을 통해 나온 원-핫 벡터 또한 희소 벡터입니다.\n\n## 밀집 표현(Dense Representation)\n\n밀집 표현(Dense Representation)은 희소 표현(Sparse Representation)과 반대대는 표현입니다. 희소 표현의 일종인 원-핫 인코딩에서는 벡터의 차원이 곧 단어 집합의 크기이고, 표현하고자 하는 단어의 인덱스의 값만 1이고 나머지는 모두 0인 `ex) [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]` 표현 방식이지만, 밀집 표현은 다릅니다.\n\n만약 단어 집합의 크기가 10000이라 가정해본다면, 이를 원-핫 인코딩을 통해 희소 벡터(희소 표현을 통해 생성된 벡터)로 표현하게 되면 차원이 10000인 희소 벡터가 생성될 것입니다.\n\n하지만 이를 밀집 표현으로 나타내고 사용자가 밀집 표현의 차원을 128로 설정했다면, 밀집 벡터(밀집 표현을 통해 생성된 벡터)의 차원은 128이 되며 벡터 안의 모든 값들은 실수가 됩니다.\n\n이와 같이 단어를 **밀집 벡터**로 표현하는 과정을 **워드 임베딩**이라고 합니다.\n\n\n## 워드 임베딩(Word Embedding)\n\n워드 임베딩이란, 단어를 **밀집 벡터(Dense Vector)**의 형태로 표현하는 방법입니다. 또한 이 워드 임베딩 과정을 거쳐 나온 밀집 벡터의 이름을 **임베딩 벡터(Embedding Vector)**라고 합니다.\n\n아래는 원-핫 벡터와 임베딩 벡터의 차이를 나타낸 표입니다.\n\n| |원-핫 벡터|임베딩 벡터|\n|------|---|---|\n|차원|고차원|저차원|\n|다른 표현|희소 벡터의 일종|밀집 벡터의 일종|\n|표현 방법|수동|훈련 데이터로부터 학습|\n|값의 타입|0, 1|real number|\n","excerpt":"희소 표현(Sparce Representation…","fields":{"slug":"/Pytorch05/"},"frontmatter":{"date":"May 02, 2021","title":"자연어 처리(NLP)의 전처리 - 워드 임베딩","tags":["Pytorch"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n\n## 원-핫 인코딩(One-Hot Encoding)\n\n지난 게시물인 [정수 인코딩](https://mintyu.github.io/Pytorch03/)에서는 Vocabulary의 각 단어에 인덱스를 부여하는 정수 인코딩까지 마쳤습니다. 그리고 이후 원-핫 인코딩과 워드 임베딩을 통해 단어들을 벡터로 바꿔준다고 말미에 언급했었습니다. 이번 게시물은 그 중 \"원-핫 인코딩(One-Hot Encoding)\"에 대한 내용입니다.\n\n### 원-핫 인코딩이란?\n\n원-핫 인코딩이란, 단어 집합의 크기를 차원으로 하고 표현하고 싶은 단어의 인덱스에 1의 값을 부여하고, 다른 인덱스에는 0을 부여하는 단어의 벡터 표현 방식입니다. 이렇게 표현된 벡터의 이름이 원-핫 벡터(One-Hot Vector)입니다. 여기서 단어의 인덱스는 앞서 정수 인코딩을 통해 맵핑한 데이터를 기반으로 합니다.\n\n예시로, `\"자연어 전처리 과정입니다.\"` 라는 한글로 된 문장을 원-핫 벡터로 만드는 과정을 보겠습니다.\n\n```python\nfrom konlpy.tag import Okt  \nokt = Okt()  \ntoken = okt.morphs(\"자연어 전처리 과정입니다.\")  \nprint(token)\n```\n\n`konlpy` 모듈의 `Okt` 형태소 분석기를 통해 문장에 대해 토큰화를 수행하는 과정입니다.\n\n\n이 과정에서 `konlpy` 모듈이 설치되지 않았다면 `$pip install konlpy` 명령어를 통해 설치해주시면 되고, 실행 과정에서 No JVM 오류가 발생한다면 JVM 설치를 진행해주시면 됩니다. 필자의 경우 도커 컨테이너 상에서 실습을 진행하고 있기에 `$apt install default-jdk`를 통해 설치를 진행했습니다. (각자의 운영체제 상황에 맞는 설치 방법으로 설치하시면 됩니다.)\n\n실행 결과는 다음과 같습니다.\n\n![](1.png)\n\n그리고 아래와 같이 각 토큰에 대해 인덱스를 부여해줍니다.\n\n```python\nword2index = {}\nfor voca in token:\n     if voca not in word2index.keys():\n       word2index[voca] = len(word2index)\nprint(word2index)\n```\n\n결과는 다음과 같습니다.\n\n![](2.png)\n\n```python\ndef one_hot_encoding(word, word2index):\n    one_hot_vector = [0]*(len(word2index))\n    index = word2index[word]\n    one_hot_vector[index] = 1\n    return one_hot_vector\n```\n\n위는 토큰을 입력하면 그에 해당하는 원-핫 벡터를 반환해주는 `one_hot_encoding`함수입니다.\n\n다음과 같이 토큰을 통해 함수를 호출하면, 원-핫 벡터를 얻을 수 있습니다.\n\n```python\none_hot_encoding(\"자연어\",word2index)\n```\n\n![](3.png)\n\n함수에 `\"자연어\"` 라는 토큰을 입력으로 넣었더니, `[1, 0, 0, 0, 0, 0]` 이라는 원-핫 벡터를 리턴했습니다.\n\n앞에서 `\"자연어\"` 토큰은 인덱스 0번으로 정수 인코딩이 되었으니, 해당하는 0번 인덱스만 1의 값을 갖는 원-핫 벡터가 나오게 됩니다.\n\n### 원-핫 인코딩의 한계\n\n원-핫 인코딩과 같은 표현 방식은, 단어의 수가 늘어날 수록 벡터의 크기가 점점 커진다는 단점이 있습니다. 단어 집합(Vocabulary)의 크기가 곧 원-핫 벡터의 차수이기 때문에, 단어의 수가 많으면 벡터를 저장하는데 리소스가 많이 필요할 뿐만 아니라 연산에서도 불리합니다.\n\n또한, 원-핫 벡터는 단어의 유사도를 표현하지 못합니다. 원-핫 인코딩을 통해서는 `['오렌지', '사과', '개', '고양이']` 이와 같은 단어 집합이 있을 때, 원-핫 인코딩을 거치면 `[1, 0, 0, 0]`, `[0, 1, 0, 0]`, `[0, 0, 1, 0]`, `[0, 0, 0, 1]` 의 4개의 벡터로 표현됩니다. 인간은 단어 집합을 보고 오렌지와 사과는 과일이며 개와 고양이는 동물이므로 서로 유사한 특징을 묶어낼 수 있지만, 원-핫 벡터로는 그런 내용들을 포함할 수 없습니다. 인간도 단어 집합을 모르는 상태에서 원-핫 벡터만 봐서는 무엇과 무엇이 서로 유사한지 전혀 알 수 없을 것입니다.\n\n따라서 단어 간 유사도까지 표현할 수 있는 워드 임베딩 방식을 많이 채택합니다. ","excerpt":"원-핫 인코딩(One-Hot Encoding) 지난 게시물인 정수 인코딩에서는 Vocabulary…","fields":{"slug":"/Pytorch04/"},"frontmatter":{"date":"Apr 25, 2021","title":"자연어 처리(NLP)의 전처리 - 원-핫 인코딩","tags":["Pytorch"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 정수 인코딩\n\n`enumerate()`는 순서가 있는 자료형(list, set, tuple, dictionary, string)을 입력으로 받아, 인덱스를 순차적으로 리턴해줍니다. 앞선 [Vocabulary](https://mintyu.github.io/Pytorch02/) 게시물에서 만든 단어 집합을 가져와서 정수로 바꿔줍니다.\n\n인덱스 0과 1은 다른 용도로 사용하기 위해 남겨두고, 나머지 인덱스인 2부터 차례대로 부여합니다.\n\n```python\nword_to_index = {word[0] : index + 2 for index, word in enumerate(vocab)}\nword_to_index['pad'] = 1\nword_to_index['unk'] = 0\n```\n\n<br/>\n\n```python\nencoded = []\nfor line in tokenized: #입력 데이터에서 1줄씩 문장을 읽음\n    temp = []\n    for w in line: #각 줄에서 1개씩 글자를 읽음\n    \ttry:\n        \ttemp.append(word_to_index[w]) # 글자를 해당되는 정수로 변환\n      \texcept KeyError: # 단어 집합에 없는 단어일 경우 unk로 대체된다.\n        \ttemp.append(word_to_index['unk']) # unk의 인덱스로 변환\n\n    encoded.append(temp)\n\nprint(encoded[:10]) # 10개 항목만 출력\n```\n\n출력 결과를 보면 다음과 같습니다.\n\n![](1.png)\n\n이 결과에서 볼 수 있듯, 문장들의 길이는 다 다르며, 문장마다 배열의 길이가 다릅니다.\n\n```python\nmax_len = max(len(l) for l in encoded)\nprint('리뷰의 최대 길이 : %d' % max_len)\nprint('리뷰의 최소 길이 : %d' % min(len(l) for l in encoded))\nprint('리뷰의 평균 길이 : %f' % (sum(map(len, encoded))/len(encoded)))\nplt.hist([len(s) for s in encoded], bins=50)\nplt.xlabel('length of sample')\nplt.ylabel('number of sample')\nplt.show()\n```\n\n![](2.png)\n\n문장의 최대 길이는 63, 최소 길이는 1, 평균은 15.62로 균일하지 않음을 알 수 있습니다. 여기에서, 가장 긴 문장의 길이인 63으로 길이를 맞춰주어야 합니다. 이 때 필요한 것이 앞에서 본 `pad` 토큰입니다. 앞서, (정수 인코딩을 진행하며 0번 인덱스에는 `unk`, 1번 인덱스에는 `pad`을 할당했었습니다.) 길이가 63보다 짧은 문장의 남는 공간에 pad 토큰을 넣음으로써 길이를 맞춰줄 수 있습니다.\n\n```python\nfor line in encoded:\n    if len(line) < max_len: # 현재 샘플이 정해준 길이보다 짧으면\n        line += [word_to_index['pad']] * (max_len - len(line)) # 나머지는 전부 'pad' 토큰으로 채운다.\n```\n\n다시 결과를 출력해보겠습니다.\n\n```python\nmax_len = max(len(l) for l in encoded)\nprint('리뷰의 최대 길이 : %d' % max_len)\nprint('리뷰의 최소 길이 : %d' % min(len(l) for l in encoded))\nprint('리뷰의 평균 길이 : %f' % (sum(map(len, encoded))/len(encoded)))\nplt.hist([len(s) for s in encoded], bins=50)\nplt.xlabel('length of sample')\nplt.ylabel('number of sample')\nplt.show()\n```\n\n![](3.png)\n\n패딩을 통해 길이가 모두 63으로 통일된 것을 확인할 수 있습니다!\n\n이렇게 만들어진 전처리의 결과물의 형태는 다음과 같습니다.\n\n```python\nprint(encoded[:3])\n```\n\n![](4.png)\n\n길이가 모두 63으로 맞춰졌으며, 빈 공간은 모두 1로 채워진 것을 직접 눈으로 확인해 보았습니다.\n\n이제 단어들을 고유한 정수로 맵핑하였으니, 각 정수를 고유한 단어 벡터로 바꾸는 작업이 필요합니다. 이 작업을 **임베딩(Embedding)**이라고 합니다. 단어 벡터를 얻는 방법은 크게 원-핫 인코딩과 워드 임베딩이 있는데, 주로 워드 임베딩이 사용됩니다.\n\n다음 게시물에서는 원-핫 인코딩은 무엇인지, 또 무슨 문제 때문에 주로 Word2Vec을 사용하는지에 대해 다루도록 하겠습니다.","excerpt":"정수 인코딩 는 순서가 있는 자료형(list, set, tuple, dictionary, string)을 입력으로 받아, 인덱스를 순차적으로 리턴해줍니다. 앞선 Vocabulary 게시물에서 만든 단어 집합을 가져와서 정수로 바꿔줍니다. 인덱스…","fields":{"slug":"/Pytorch03/"},"frontmatter":{"date":"Apr 15, 2021","title":"자연어 처리(NLP)의 전처리 - 정수 인코딩, 패딩","tags":["Pytorch"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 단어 집합(Vocabulary) 생성\n\n단어 집합(vocabuary)이란 중복을 제거한 텍스트의 총 단어의 집합(set)을 의미합니다. 우선, 실습을 위해서 깃허브에서 '네이버 영화 리뷰 분류하기' 데이터를 다운로드하겠습니다. 네이버 영화 리뷰 데이터는 총 20만 개의 영화 리뷰를 긍정 1, 부정 0으로 레이블링한 데이터입니다.\n\n```python\nimport urllib.request\nimport pandas as pd\nfrom konlpy.tag import Mecab\nfrom nltk import FreqDist\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nurllib.request.urlretrieve(\"https://raw.githubusercontent.com/e9t/nsmc/master/ratings.txt\", filename=\"ratings.txt\")\ndata = pd.read_table('ratings.txt') # 데이터프레임에 저장\ndata[:9]\n```\n\n![](1.png)\n\n```python\nprint('전체 샘플의 수 : {}'.format(len(data)))\n# 전체 샘플의 수 : 200000\n```\n\n<br/>\n\n```python\nsample_data = data[:100] # 임의로 100개만 저장\n```\n<br/>\n\n아래와 같이 정규 표현식을 통해 데이터를 정제하는 과정을 거칩니다.\n\n```python\nsample_data['document'] = sample_data['document'].str.replace(\"[^ㄱ-ㅎㅏ-ㅣ가-힣 ]\",\"\")\nsample_data[:9]\n\n```\n\n![](2.png)\n\n그 다음은 토큰화를 수행하기에 앞서, 불용어(Stopword)를 제거하기 위해 불용어를 임의로 정해주었습니다.\n\n불용어란, 자주 등장하지만 분석을 하는 것에 있어서는 큰 도움이 되지 않는 단어들을 말합니다.\n\n```python\nstopwords=['의', '가', '이', '은', '들', '는', '좀', '잘', '걍', '과', '도', '를', '으로', '자', '에', '와', '한', '하다']\n```\n<br/>\n\n형태소 분석기는 Mecab을 사용합니다.\n\n```python\ntokenizer = Mecab()\n\ntokenized=[]\nfor sentence in sample_data['document']:\n    temp = tokenizer.morphs(sentence) # 토큰화\n    temp = [word for word in temp if not word in stopwords] # 불용어 제거\n    tokenized.append(temp)\n\nprint(tokenized[:9])\n```\n![](3.png)\n\n이제 단어집합(Vocabulary)을 생성합니다. NLTK에서는 빈도수 계산 도구인 FreqDist()를 지원합니다.\n\n```python\nvocab = FreqDist(np.hstack(tokenized))\nprint('단어 집합의 크기 : {}'.format(len(vocab)))\n# 단어 집합의 크기 : 664\n```\n\n<br/>\n\n`vocab`에는 단어를 키(key)로, 단어에 대한 빈도수가 값(value)으로 저장됩니다. 다음과 같이 vocab에 단어를 입력하면 등장한 빈도수를 리턴합니다.\n\n```python\nvocab['재밌']\n# 10\n```\n<br/>\n\n만약 vocab의 사이즈를 원하는대로 조정하고싶다면, `.most_common()`을 통해 할 수 있습니다. 예시는 다음과 같습니다.\n\n```python\nvocab_size = 100\nvocab = vocab.most_common(vocab_size)\nprint('단어 집합의 크기 : {}'.format(len(vocab)))\n# 단어 집합의 크기 : 100\n\n```","excerpt":"단어 집합(Vocabulary) 생성 단어 집합(vocabuary)이란 중복을 제거한 텍스트의 총 단어의 집합(set…","fields":{"slug":"/Pytorch02/"},"frontmatter":{"date":"Apr 13, 2021","title":"자연어 처리(NLP)의 전처리 - 단어 집합 생성","tags":["Pytorch"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n자연어 처리는 일반적으로 토큰화, 단어 집합 생성, 정수 인코딩, 패딩, 벡터화의 과정을 거치게 됩니다. pytorch를 통한 자연어 처리를 진행하기 전에, 이 일련의 과정들을 알아보도록 하겠습니다.\n\n## 토큰화(Tokenization)\n\n주어진 텍스트를 단어 또는 문자 단위로 자르는 것을 **토큰화**라고 합니다.\n\n### 1. 띄어쓰기로 토큰화\n\n```python\n# 토큰화 전\n\"It does not matter how slowly you go as long as you do not stop\"\n```\n<br/>\n\n```python\n# 토큰화 후\n['It', 'does', 'not', 'matter', 'how', 'slowly', 'you', 'go', 'as', 'long', 'as', 'you', 'do', 'not', 'stop']\n```\n<br/>\n영어의 경우, 띄어쓰기 단위로 토큰화를 진행해도 단어들 간에 구분이 명확하기 때문에 토큰화 작업이 수월합니다. 하지만, 한국어의 경우 조사, 접사 등으로 인해 단순 띄어쓰기 단위로 토큰화를 진행하게 되면 같은 단어일지라도 조사와 접사 때문에 다른 단어로 인식되기 때문에 단어 집합(vocabulary)의 크기가 지나치게 커지는 문제가 존재합니다. 따라서 한국어의 경우 토큰화 과정이 영어에 비해 더 까다롭다고 할 수 있습니다.\n\n### 2. 형태소 토큰화\n\n```python\n# 토큰화 전\n\"당신이 멈추지 않는 이상, 얼마나 천천히 가는지는 전혀 문제되지 않습니다\"\n```\n<br/>\n\n```python\n# 토큰화 후\n['당신', '이', '멈추', '지', '않', '는', '이상', ',', '얼마나', '천천히', '가', '는지', '는', '전혀', '문제', '되', '지', '않', '습니다']\n```\n<br/>\n앞서 언급했듯, 한글의 경우는 띄어쓰기 단위로만 토큰화하는 경우 한계가 있기 때문에 위와 같이 단어를 형태소로 분리하여 토큰화를 진행하면 같은 의미의 단어끼리 보다 더 정확히 묶을 수 있게 됩니다.\n\n### 3. 문자 토큰화\n\n```python\n# 토큰화 전\n\"A Dog Run back corner near spare bedrooms\"\n```\n<br/>\n\n```python\n# 토큰화 후\n['A', ' ', 'D', 'o', 'g', ' ', 'R', 'u', 'n', ' ', 'b', 'a', 'c', 'k', ' ', 'c', 'o', 'r', 'n', 'e', 'r', ' ', 'n', 'e', 'a', 'r', ' ', 's', 'p', 'a', 'r', 'e', ' ', 'b', 'e', 'd', 'r', 'o', 'o', 'm', 's']\n```\n<br/>\n\n띄어쓰기, 형태소 이외에도 문자 단위로 토큰화를 진행하게 되는 경우도 있습니다.\n\n## 토큰화 도구\n\n영어의 경우 토큰화를 사용하는 도구로서 대표적으로 spaCy와 NLTK가 있습니다. 물론, 파이썬 기본 함수인 split으로 토큰화를 할 수도 있습니다.\n\n다음과 같은 문장이 있다고 가정해봅시다.\n\n```python\nen_text = \"A Dog Run back corner near spare bedrooms\"\n```\n\n### 1. spaCy\n\n```python\nimport spacy\nspacy_en = spacy.load('en')\n\ndef tokenize(en_text):\n    return [tok.text for tok in spacy_en.tokenizer(en_text)]\n\nprint(tokenize(en_text))\n# ['A', 'Dog', 'Run', 'back', 'corner', 'near', 'spare', 'bedrooms']\n\n\n```\n\n### 2. NLTK\n\n```python\nimport nltk\nnltk.download('punkt')\n\nfrom nltk.tokenize import word_tokenize\nprint(word_tokenize(en_text))\n# ['A', 'Dog', 'Run', 'back', 'corner', 'near', 'spare', 'bedrooms']\n\n```\n\n### 3. split()\n\n```python\nprint(en_text.split())\n# ['A', 'Dog', 'Run', 'back', 'corner', 'near', 'spare', 'bedrooms']\n```\n","excerpt":"자연어 처리는 일반적으로 토큰화, 단어 집합 생성, 정수 인코딩, 패딩, 벡터화의 과정을 거치게 됩니다. pytorch를 통한 자연어 처리를 진행하기 전에, 이 일련의 과정들을 알아보도록 하겠습니다. 토큰화(Tokenization…","fields":{"slug":"/Pytorch01/"},"frontmatter":{"date":"Apr 07, 2021","title":"자연어 처리(NLP)의 전처리 - 토큰화","tags":["Pytorch"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 문제 정보\n\n#### 제한\n- 시간 제한 : 2초\n- 메모리 제한 : 512MB\n\n#### 출처\n- Olympiad > USA Computing Olympiad > 2016-2017 Season > USACO 2017 February Contest > Bronze 1번\n\n#### 알고리즘 분류\n- 구현\n\n\n## 문제\n\n닭이 길을 건너간 이유는 과학적으로 깊게 연구가 되어 있지만, 의외로 소가 길을 건너간 이유는 거의 연구된 적이 없다. 이 주제에 관심을 가지고 있었던 농부 존은 한 대학으로부터 소가 길을 건너는 이유에 대한 연구 제의를 받게 되었다.\n\n존이 할 일은 소가 길을 건너는 것을 관찰하는 것이다. 존은 소의 위치를 N번 관찰하는데, 각 관찰은 소의 번호와 소의 위치 하나씩으로 이루어져 있다. 존은 소를 10마리 가지고 있으므로 소의 번호는 1 이상 10 이하의 정수고, 소의 위치는 길의 왼쪽과 오른쪽을 의미하는 0과 1 중 하나다.\n\n이 관찰 기록을 가지고 소가 최소 몇 번 길을 건넜는지 알아보자. 즉 같은 번호의 소가 위치를 바꾼 것이 몇 번인지 세면 된다.\n\n## 입력\n\n첫 줄에 관찰 횟수 N이 주어진다. N은 100 이하의 양의 정수이다. 다음 N줄에는 한 줄에 하나씩 관찰 결과가 주어진다. 관찰 결과는 소의 번호와 위치(0 또는 1)로 이루어져 있다.\n\n## 출력\n\n첫 줄에 소가 길을 건너간 최소 횟수를 출력한다.\n\n#### <예제 입력 1>\n\n```\n8\n3 1\n3 0\n6 0\n2 1\n4 1\n3 0\n4 0\n3 1\n```\n\n##### <예제 출력 1>\n\n`3`\n\n## 풀이\n\n문제의 핵심은 다음과 같다.\n\n1. 소의 위치는 0과 1로 표현된다.\n\n2. 위치가 0에서 1, 또는 1에서 0으로 바뀐 경우가 길을 건넌 경우에 해당한다.\n\n문제의 입력 형식과 비교해 보았을 때, **소의 위치가 처음 초기화되는 경우**에는 길을 건넌 것으로 카운트하지 않으며, **소의 위치가 그대로인 경우**에도 카운트하지 않습니다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n\n    int n = 0;\n\n    int cow[11] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};\n    // 소의 초기 위치를 -1로 설정(default)\n\n    cin >> n;\n\n    int count = 0;\n\n    for (int i = 1; i <= n; i++)\n    {\n        int cownum, pos;\n\n        cin >> cownum >> pos;  // test case 입력\n\n        if (cow[cownum] == -1) { // 소의 위치가 default인 경우\n\n            cow[cownum] = pos; // 입력값으로 초기화\n\n        }\n\n        else if (cow[cownum] != pos && cow[cownum] != -1)\n        // 소의 위치가 -1이 아닌 다른 값으로 초기화되어있으며, 이미 초기화된 값과 다른 위치값을 입력받은 경우\n\n        {\n            cow[cownum] = pos; // 입력값으로 위치 재설정\n\n            count += 1; // 이동 횟수 증가!\n        }\n\n    }\n\n    cout << count << endl;\n\n    return 0;\n}\n```\n\n위 코드와 같이 **소의 위치가 처음 초기화되는 경우**와 **소의 위치가 그대로인 경우**만 체크해주더라도 쉽게 풀 수 있는 문제였습니다.\n","excerpt":"문제 정보 제한 시간 제한 : 2초 메모리 제한 : 512MB 출처 Olympiad > USA Computing Olympiad > 2016-2017 Season > USACO 2017 February Contest > Bronze…","fields":{"slug":"/BOJ14467/"},"frontmatter":{"date":"Jul 04, 2020","title":"백준 [14467] - 소가 길을 건너간 이유 1","tags":["BOJ(C++)"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## VSCode 괄호 Tab키로 나가기\n\nVSCode에는 기본적으로 괄호를 한 쪽`\" ( \"` 입력하면 나머지 한 쪽도 자동 완성되어 `\" ( ) \"`이렇게 입력됩니다.\n\n이 자동완성 기능을 끄는 방법도 있겠지만, 어차피 괄호를 열었다면 닫는 버튼을 한번 더 입력해야하는 것은 마찬가지입니다.\n\n다른 IDE나 Editor에서는 `Tab`버튼을 통해 괄호나 따옴표 밖으로 나가는 것을 지원하는것 같았는데 VSCode 자체에서는 그 기능을 찾을 수가 없었습니다.\n\n그래서 더 쉽게 괄호를 탈출하는 방법은 없을까 해서 찾던 중, [깃허브](https://github.com/microsoft/vscode/issues/22864)에서 그 해결 방법을 찾을 수 있었습니다.\n\n바로 **\"TabOut\"**이라는 Extension입니다.\n\n### 설치\n\n![](1.png)\n\n좌측 메뉴에서 Extension 탭을 선택한 후, 마켓플레이스에서 `\"TabOut\"`을 검색한 후 설치해줍니다.\n\n![](2.png)\n\n설치가 완료되었다면 탭을 통해 쌍(Pair)이 있는 괄호나 따옴표의 한 단계 밖으로 나갈 수 있습니다.\n","excerpt":"VSCode 괄호 Tab키로 나가기 VSCode…","fields":{"slug":"/TabOut/"},"frontmatter":{"date":"May 03, 2020","title":"VSCode 괄호, 따옴표 Tab으로 나가기 [VSCode]","tags":["VSCode"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## VSCode Format?\n\nVSCode에는 지정된 형식으로 코드를 깔끔하고 예쁘게 정리해줄 수 있는 기능이 존재합니다.\n\n그 기능은 바로 Format 기능인데, VSCode에서 별다른 설정을 만지지 않았다면 `⌥ + ⇧ + F`로 실행할 수 있습니다. (Windows 운영체제의 경우 `Alt + Shift + F`)\n\n아무생각없이 코딩을 하다 보면, 다음과 같이 가독성이 떨어질 수 있습니다.\n\n![](1.png)\n\n중괄호가 시작하는 위치도 일정하지 않고, 들여쓰기도 일관적이지 않습니다.\n\n뿐만 아니라, 연산자와 변수가 붙어있고 배열 안의 항목들도 붙어있어 가독성이 매우 떨어집니다.\n\n(괄호에 적용된 색은 `Bracket Pair Colorizer`라는 Extention이며, 괄호의 쌍을 찾기 쉽게 색을 지정해준다. Extension에 관한 내용은 추후에 따로 포스트할 예정!)\n\n이럴 떄, 앞에서 설명했던 Format 기능을 실행하면 다음과 같이 코드가 변하게 됩니다.\n\n![](2.png)\n\n중괄호 시작 위치와 들여쓰기를 일정하게 맞춰주며, 띄어쓰기를 자동으로 적절한 위치에 삽입해줘서 가독성을 좋게 해줍니다.\n\n하지만, 아무 설정도 하지 않았다면 배열의 원소들을 둘러싸고 있는 중괄호 사이는 떨어지지 않습니다.\n\n중괄호와 원소 사이의 간격을 띄우게 되면 원소를 더 명확하게 구분할 수 있으며 가독성 향상에 도움을 주기 때문에 따로 설정해주는 것을 추천해 드립니다.\n\n설정을 진행하게 되면 다음과 같은 변화가 있습니다.\n\n```cpp\narr[3] = {1, 2, 3};\n// From this...\n\narr[3] = { 1, 2, 3 };\n// To this!\n```\n\n설정 방법은 아래와 같습니다.\n\n### 배열 원소와 중괄호 사이 띄어쓰기 설정\n\n우선, 설정을 위해서는 `⌘ + ,`를 통해 설정 탭을 열어줍니다. (Windows의 경우 `Ctrl + ,`)\n\n그리고 `clang_format`을 검색해주면 다음과 같은 항목들을 볼 수 있습니다.\n\n![](3.png)\n\n가장 위에 나오는 `Clang_format_fallback Style`항목은 따로 설정해주지 않았다면 지금 스크린샷에 나온것과 달리 `Visual Studio`라고 적혀있을 것입니다.\n\n설명에 쓰여 있는 것처럼 `Visual Studio`, `LLVM`, `Chromium`, `Google` 등의 스타일 세트를 따로 지정해줄 수도 있고,\n\n`{key: value ...}`와 같은 형태로 직접 세부 스타일 하나하나 따로 지정해줄 수도 있습니다.\n\n`Visual Studio` 스타일을 `{key: value ...}`형태로 쓰면 다음과 같습니다.\n\n```\n{ BasedOnStyle: LLVM,\nUseTab: Never,\nIndentWidth: 4,\nTabWidth: 4,\nBreakBeforeBraces: Allman,\nAllowShortIfStatementsOnASingleLine: false,\nIndentCaseLabels: false,\nColumnLimit: 0,\nAccessModifierOffset: -4 }\n```\n\n위에서 제일 마지막에 `Cpp11BracedListStyle`이라는 하나의 항목을 더 추가해주고 false로 설정하면 끝입니다.\n\n```\n{ BasedOnStyle: LLVM,\nUseTab: Never,\nIndentWidth: 4,\nTabWidth: 4,\nBreakBeforeBraces: Allman,\nAllowShortIfStatementsOnASingleLine: false,\nIndentCaseLabels: false,\nColumnLimit: 0,\nAccessModifierOffset: -4,\nCpp11BracedListStyle: false }\n```\n\n이 항목을 그대로 복사해서 `Clang_format_fallback Style` 설정의 입력란에 넣으시면 설정이 완료됩니다.\n\n### 저장하면서 형식 지정해주기(Format On Save)\n\n단축키가 상당히 불편하고 외우기 어렵다보니, 저장과 동시에 Formatting을 해주는 기능을 이용하는 것이 훨씬 간편합니다.\n\n이 설정 방식은 아까와 같이 우선 `⌘ + ,`를 통해 설정 탭을 열어줍니다. (Windows의 경우 `Ctrl + ,`)\n\n그리고 `format on save`를 검색해주면 다음과 같은 설정이 있습니다.\n\n![](4.png)\n\n체크박스에 체크를 해주시면 앞으로는 저장과 동시에 자동으로 Format 기능을 실행할 수 있습니다!\n","excerpt":"VSCode Format? VSCode에는 지정된 형식으로 코드를 깔끔하고 예쁘게 정리해줄 수 있는 기능이 존재합니다. 그 기능은 바로 Format 기능인데, VSCode에서 별다른 설정을 만지지 않았다면 로 실행할 수 있습니다. (Windows…","fields":{"slug":"/Format/"},"frontmatter":{"date":"Apr 26, 2020","title":"VSCode 저장 시 자동 format 지정 [VSCode]","tags":["VSCode"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## fstream\n\nC++에서 입력과 출력을 관리하기 위해 사용했던 `<iostream>`헤더파일과 마찬가지로, 파일을 통한 데이터 입출력을 관리하는 헤더 파일은 `<fstream>`으로 정의되어 있습니다.\n\n또한, `<iostream>`에서 입력은 istream, 출력은 ostream이라는 Class를 통해 정의된 것처럼 `<fstream>`에서 파일 열기(read)는 ifstream, 파일 쓰기(write)는 ofstream으로 Class가 정의되어 있습니다. 'i'와 'o'는 각각 in과 out을 의미합니다.\n\n`<iostream>`헤더와 `<fstream>`헤더에서는 공통적으로 데이터의 이동 방향을 철저히 '실행 파일'기준으로 처리합니다.\n\n예를 들자면, `<iostream>`을 통해 실행 파일에 데이터를 '입력'하는 것이 istream이며 '출력'하는 것이 ostream이지만\n\n실행 파일에서 `<fstream>`을 통해 txt파일에 데이터를 '입력'하는것은 ofstream이며, 파일로부터 데이터를 불러오는 것은 ifstream입니다.\n\n사실 이렇게 해석하면 굉장히 혼란의 여지가 많습니다.\n\n실행 파일에서 `<fstream>`을 통해 txt파일로 데이터를 '출력'(내보내는 것)이 ofstream이며, txt파일로부터 데이터를 '입력'받는것을 ifstream이라고 해석하는 것이 자연스럽습니다.\n\n### ifstream\n\n우선 텍스트파일로부터 데이터를 읽어오는 ifstream에 대해 먼저 알아보겠습니다.\n\nifstream 객체를 하나 생성하고, 읽어올 파일을 선택해야 합니다.\n\n이 방법에는 두 가지 방법이 있습니다.\n\n첫째는 선언과 동시에 파일을 지정해주는 방법입니다.\n\n```cpp\nifstream fin(\"text.txt\");\n```\n\n둘째는 선언 후 파일을 지정해주는 방법입니다.\n\n```cpp\nifstream fin;\nfin.open(\"text.txt\");\n```\n\n위의 두 예제 모두 `fin`이라는 이름의 객체가 `\"text.txt\"`파일을 열어놓은 상태입니다.\n\n파일이 제대로 열렸는지를 확인하는 방법은 다음과 같습니다(ifstream 객체의 이름을 fin으로 설정했다는 가정 하에 진행합니다.)\n\n```cpp\nif (!fin)\n{\n    cout << \"Error, no such file exists\" << endl;\n    exit(100);\n}\n```\n\n위 코드는 열려고 하는 파일이 존재하지 않을 때, 에러 메시지를 출력하며 프로그램을 종료합니다.\n\n파일이 잘 열렸다면, 이제 파일 안에 있는 데이터를 가져올 차례입니다.\n\n텍스트 파일의 내용은 다음과 같다고 가정하겠습니다.\n\n> text.txt\n>\n> ```\n> 1\n> 2\n> 3\n> 4\n> 5\n> ```\n\n이제 `<iostream>`헤더파일의 `cin`의 사용법과 비슷하게 정의해놓은 `fin`을 사용하면 됩니다.\n\n다음은 `text.txt`의 내용을 읽어와서 출력하는 예제입니다.\n\n```cpp\n#include <fstream>\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    ifstream fin(\"text.txt\"); // fin 객체 생성(cin 처럼 이용!)\n    if (!fin)\n    {\n        cout << \"Error, no such file exists\" << endl;\n        exit(100);\n    } // 파일 열림 확인\n\n    int i;\n    while (true)\n    {\n        fin >> i;\n        if (fin.eof()) // 읽어올 파일의 끝이면(End Of File)\n        {\n            break; // 읽기를 마치고 반복문을 나간다.\n        }\n        cout << i << endl;\n    }\n\n    fin.close(); // 파일 닫기\n\n    return 0;\n}\n```\n\nmain함수 안의 반복문을 통해 파일에서 한 단어씩 읽어온 후, 출력하는 예제입니다.\n\n`fin.eof()`는 `fin`을 통해서 읽어온 파일의 끝에 도달하면, True를 리턴합니다.\n\n이를 통해 조건문으로 파일의 끝까지 읽었을 때 반복문을 탈출하도록 할 수 있습니다.\n\n파일을 열고 잘 출력까지 마무리했다면, 파일을 닫아줄 차례입니다.\n\n예제의 `fin.close()`가 바로 그 역할입니다.\n\n사용 후 닫지 않는다면 열려있는동안 파일이 Lock되거나 다른 사람이 이용하지 못하게 될 수 있으므로, 사용 후에는 꼭 닫아주도록 합시다.\n\n#### 한 줄씩 입력을 받고 싶다면?\n\nifstream도 cin과 마찬가지로 화이트스페이스(whitespace)를 기준으로 입력을 구분합니다.\n\n따라서, 스페이스바를 통한 공백이나 줄바꿈을 통해 입력을 구분하게 됩니다.\n\n하지만, 단어가 아닌 문장으로, 띄어쓰기에 상관없이 한 줄씩 입력을 받고 싶다면 `std::getline(입력스트림 객체, 문자열 변수)`를 이용하면 됩니다.\n\n> ```\n> lorem.txt\n>\n> Lorem ipsum dolor sit amet,\n> consectetur adipiscing elit,\n> sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n> ```\n\n위와 같은 텍스트가 있다고 가정한 후, 한 줄씩 읽어와서 출력해주는 예제입니다.\n\n```cpp\n#include <fstream>\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main()\n{\n    ifstream fin(\"lorem.txt\"); // fin 객체 생성(cin 처럼 이용!)\n    if (!fin)\n    {\n        cout << \"Error, no such file exists\" << endl;\n        exit(100);\n    } // 파일 열림 확인\n\n    string str;\n    while (getline(fin, str)) // 파일이 끝날때까지 한 줄씩 읽어오기\n    {\n        cout << str << endl;\n    }\n\n    fin.close(); // 파일 닫기\n\n    return 0;\n}\n```\n\n### ofstream\n\nofstream은 데이터를 외부 파일로 저장하는 역할을 합니다.\n\nifstream과 마찬가지로, ofstream 객체를 만들고 데이터를 내보낼 파일 이름을 지정해줍니다.\n\n```cpp\nofstream fout(\"result.txt\");\n// 선언과 동시에 파일 이름 지정\n\nofstream fout;\nfout.open(\"result.txt\");\n// 선언 후 파일 이름 지정\n```\n\n이렇게 선언한 후, 앞에서 fin을 cin처럼 사용한것과 같이 fout을 cout처럼 사용해주면 됩니다.\n\nofstream에서는 지정해준 파일의 이름이 없더라도 자동으로 생성해주므로 굳이 파일이 없는 경우 오류를 출력할 필요가 없습니다.\n\n또한, 이미 내용이 저장되어 있는 파일을 지정하고 데이터를 저장해주었을 경우 내용을 덮어쓰게 됩니다.\n\n**즉, 이미 저장되어있던 내용은 삭제되고, 새로운 내용이 저장됩니다.**\n\n다음은 ofstream을 통해 `result.txt`에 1부터 5까지 줄을 바꾸어 하나씩 저장하는 예제입니다.\n\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\n\nint main()\n{\n\tofstream fout(\"result.txt\");\n\n    for(int i = 1; i <= 5; i++)\n    {\n        fout << i << endl;\n    }\n\treturn 0;\n    fout.close();\n}\n```\n\n코드를 실행하면 실행한 디렉토리 안에 다음과 같은 텍스트 파일이 생성됩니다.\n\n> ```\n> result.txt\n>\n> 1\n> 2\n> 3\n> 4\n> 5\n>\n> ```\n\n여기까지 C++로 외부 파일과 입출력을 통해 상호작용하는 방법에 대해 알아보았습니다.\n\n아마 다른 언어로 이미 파일 입출력을 학습했던 경험이 있다면 크게 어렵게 느껴지지는 않을 것이라 예상됩니다.\n\n(파이썬에서의 파일 입출력 방식과 굉장히 비슷하다고 느꼈습니다.)\n","excerpt":"fstream C++에서 입력과 출력을 관리하기 위해 사용했던 헤더파일과 마찬가지로, 파일을 통한 데이터 입출력을 관리하는 헤더 파일은 으로 정의되어 있습니다. 또한, 에서 입력은 istream, 출력은 ostream이라는 Class…","fields":{"slug":"/cpp12/"},"frontmatter":{"date":"Apr 07, 2020","title":"바닥에서 시작하는 C++ (12) - 파일 입출력","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## C++의 문자열?\n\nC++은 문자열을 쉽게 다룰 수 있는 String Class를 제공합니다.\n\nC++에서 String Class를 사용하기 위해서는 String 헤더 파일을 포함해야 합니다.\n\n```cpp\n#include <string>\n```\n\n또한, String Class는 std namespace에 속해 있으므로 `using namespace std;`를 사용하거나 직접 `std::string`을 통해 사용해야 합니다.\n\nC++에서 String도 다른 일반적인 변수들처럼 사용됩니다.\n\n다른 변수들과 마찬가지로 선언과 동시에 초기화를 해줄 수도 있고, 선언 후 나중에 초기화를 해줄 수도 있습니다.\n\n다음 예제는 `using namespace std;`가 작성되어있다는 전제 하에 진행됩니다.\n\n```cpp\nstring str = \"Hello!\";\n// 선언과 동시에 초기화\n\nstring str;\nstr = \"Welcome to Blog!\";\n// 선언 이후 초기화\n```\n\n### method?\n\nString Class에서는 다양한 메소드들도 제공합니다.\n\n다음 세 개 정도만 알아두어도 간단한 문자열 컨트롤은 가능합니다.\n\n1. length()\n2. size()\n3. find()\n\n간단히 사용 방법을 알아봅시다!\n\n#### length(), size()\n\n일반적으로, `length()`와 `size()`는 같은 값을 반환합니다.\n\n이 둘이 완벽하게 같은 기능을 한다고 알고 있어도 사용하는데 별 무리는 없지만, 의미가 미묘하게 다릅니다.\n\n`length()`메소드는 **문자열의 길이**를 나타내지만, `size()`메소드는 **string 객체가 메모리에서 실제 사용하고 있는 크기**를 나타냅니다.\n\n사용 방법 자체는 둘이 같기때문에 따로 신경써주지 않아도 됩니다.\n\n```cpp\nstring str = \"Hello!\";\n\ncout << str.length(); // 6\n\ncout << str.size(); // 6\n```\n\n#### find()\n\n`find()`는 문자열을 찾고, 그 문자열의 시작 위치를 반환하는 메소드입니다.\n\n첫번째 인자로 찾을 '문자'나 '문자열'을 입력해주고, 두번째 인자로는 찾기 시작할 '위치'를 입력해줍니다.\n\n두번째 인자의 default값은 0으로, 입력해주지 않으면 처음부터 탐색합니다.\n\n`\"Welcome to my blog!\"`라는 문자열에서 `\"my\"`라는 문자열의 시작 위치를 출력하는 예제입니다.\n\n```cpp\nstring str = \"Welcome to my blog!\";\n\ncout << str.find(\"my\"); // 11\n```\n\n`\"W\"`가 0번 index이므로 `\"my\"`가 처음 시작하는 위치인 11이 출력된 것을 볼 수 있습니다.\n\n다음은 `\"abbbba\"`라는 문자열에서 두번째 `\"a\"`라는 문자의 시작 위치를 출력하는 예제입니다.\n\n```cpp\nstring str = \"abbbba\";\n\ncout << str.find(\"a\", str.find(\"a\") + 1); // 5\n```\n\n위 예제에서 두번째 인자로 입력한 `str.find(\"a\")`는 0번째 index의 `\"a\"`를 찾고 0을 반환할 것입니다.\n\n이 값에 1을 더해줘서 첫번째로 `\"a\"`가 등장한 위치 다음부터 탐색하도록 하여 2번째 `\"a\"`의 위치를 찾아 5라는 값을 반환하게 됩니다.\n","excerpt":"C++의 문자열? C++은 문자열을 쉽게 다룰 수 있는 String Class를 제공합니다. C++에서 String Class를 사용하기 위해서는 String 헤더 파일을 포함해야 합니다. 또한, String Class는 std namespace…","fields":{"slug":"/cpp11/"},"frontmatter":{"date":"Apr 04, 2020","title":"바닥에서 시작하는 C++ (11) - 문자열(String)","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Alfred\n\n오늘 소개할 어플은 Alfred입니다.\n\n![Alfred4](1.png)\n\n원래 Paste2를 사용하고 있었는데, 갑자기 구독형으로 정책을 바꾸는바람에 대체 앱을 서칭하다 발견했습니다.\n\n(~~비싸긴 하지만~~)Paste2보다 훨씬 기능도 강력하고, 무엇보다도 'Snippet'기능이 마음에 쏙 들었습니다.\n\n기능을 좀 살펴본 후 아무 고민도 없이 갈아탔습니다!\n\nAlfred의 Default 단축키는 `⌥ + Space`로 설정되어있습니다.\n\n![search](3.png)\n\n눌러보면, 기존 맥의 Spotlight 검색 기능과 매우 비슷한 검색창이 나옵니다.\n\n여기에 `alfred`를 검색하고 엔터를 누르면 다음과 같은 preference창을 볼 수 있습니다.\n\n![Preference](2.png)\n\n저는 우선 Appearance부터 설정해줬습니다. 앞서 설명했던 Search Bar의 테마를 설정할 수 있습니다.\n\n기본제공되는 테마를 쓰려 했지만 별로 마음에 드는게 없어서 테마를 따로 만들었습니다.\n\n![appearance](4.png)\n\n테마를 만드는 과정이 굉장히 쉽고 간단하기 때문에 마음에 들지 않는다면 본인의 입맛에 맞는 테마를 만들어 쓰면 됩니다.\n\n이제 Snippet 기능을 본격적으로 사용해봅시다!\n\n### Snippets\n\n![snippets](5.png)\n\nFeatures 탭에서 Snippets라는 기능을 설정해 줄 수 있습니다.\n\n흔히 말하는 자동 완성 기능이라고 생각하면 쉽습니다.\n\n![](6_1.png)\n\n설정 창은 위와 같이 생겼으며, 우측 상단의 \"Automatically expand snippets by keyword\"를 체크하게 되면 따로 동작을 추가로 입력하지 않아도 자동으로 keyword를 인식하고 자동으로 입력해줍니다.\n\n예시로 몇 개를 만들어두었는데, 사용법은 굉장히 간단합니다.\n\n좌측은 Collection입니다. 같은 기능을 하는 Snippet들을 묶어서 정리할 수 있으며, 공통된 prefix를 지정해줄 수 있습니다.\n\n저는 C++ 관련 Snippet의 prefix를 `#`으로 설정해 두었습니다.\n\n이 Snippet들 중 CPP initial이라는 항목은 어떻게 설정되어있는지 보도록 하겠습니다.\n\n![](7.png)\n\nname에는 그 Snippet의 기능을 설명해주는 이름이면 충분하고, keyword는 Collection에서 지정해주었던 prifix와 함께 쓰여서 동작하게되므로 본인이 편한 약어를 지정해주면 됩니다.\n\n예를 들어, CPP initial이라는 이름의 Snippet은 Collection의 prifix가 `#`이고 keyword가 `init`이므로, `#init`을 입력하게 되면 다음과 같이 설정해둔 내용으로 바로 변환되어 입력됩니다.\n\n``` cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\t\n\treturn 0;\n}\n```\n\n이를 통해 반복적인 작업을 최대한 줄여줄 수 있습니다.\n\nSnippet 설정창의 왼쪽 아래부분 Curly bracket(`{ }`)을 통해 Placeholder를 설정해줄 수도 있습니다.\n\nPlaceholder를 통해 출력할 수 있는 기능은 아래와 같습니다.\n\n1. 오늘 날짜 출력\n2. 다른 날짜 출력\n3. 클립보드 히스토리\n4. 랜덤 출력\n5. Snippet 실행 후 최종 커서 위치 설청\n\n이를 이용하면 그 때마다 상황에 맞는 데이터를 출력해줄 수 있습니다.\n\nPlaceholder의 사용법에 대한 더 자세한 설명은 다음 링크에서 확인할 수 있습니다.\n\n[https://www.alfredapp.com/help/workflows/advanced/placeholders/](https://www.alfredapp.com/help/workflows/advanced/placeholders/)","excerpt":"Alfred 오늘 소개할 어플은 Alfred입니다.  원래 Paste2를 사용하고 있었는데, 갑자기 구독형으로 정책을 바꾸는바람에 대체 앱을 서칭하다 발견했습니다. (비싸긴 하지만)Paste2보다 훨씬 기능도 강력하고, 무엇보다도 'Snippet…","fields":{"slug":"/Alfred/"},"frontmatter":{"date":"Apr 04, 2020","title":"MAC 필수 어플 - Alfred(Snippet)","tags":["MAC"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 2주차 Linux(Ubuntu)로 살아보기\n\n![](1.png)\n\n18.04버전의 화면 모습입니다. 알아보니 원래 Ubuntu는 'GNOME'이라는 데스크탑 환경을 채택했다가, 'Unity'환경으로 바꾸었었고, 이제 다시 18.04버전부터 'Unity'와 상당히 유사하게 디자인 된 테마를 달고 나온 'GNOME'이 다시 기본 데스크탑 환경으로 채택되었다고 합니다.\n\n기대했던 것보다 훨씬 깔끔하게 디자인되어 있는 것 같아서 나쁘지 않다는 생각을 했습니다. 하지만, 몇몇 프로그램을 시작해보면서 불편함을 느끼기 시작했습니다.\n\n![](2.png)\n\nUbuntu를 설치하고 가장 먼저 실행해본 것은 Firefox!\n\n뭔가 벌써 불편함이 느껴지지는 않으신가요?\n\n아마 불편함을 느꼈다면 저와 같은 생각이실겁니다.\n\n![](3_1.png)\n\n안그래도 좌측의 런처(Launcher)때문에 작업 화면이 손해를 보고 있는데, 상단바 때문에 상당히 큰 공간이 낭비되고 있다는게 보이시나요?\n\n심지어 메뉴바도 활성화되지 않은 상태입니다. 만약 메뉴바가 활성화되어있었다면 더 큰 공간을 차지하게 되는 것이죠.\n\n인터넷을 뒤져보니 이런 불편함을 호소하는 사람들은 저뿐만이 아니었고, 해결 방법을 어렵지 않게 찾을 수 있었습니다.\n\n### 1. Top Bar 제거하기 - Unite\n\n우선 [https://addons.mozilla.org/ko/firefox/addon/gnome-shell-integration/](https://addons.mozilla.org/ko/firefox/addon/gnome-shell-integration/)에 들어가서 Add-On을 설치해줍니다.\n\n그 후, 바탕화면에서 우클릭 후 'Open Terminal'로 Terminal을 엽니다\n\n![](4.png)\n\n위와 같이 Terminal이 열렸다면 다음처럼 입력해줍니다.\n\n```\n$ sudo apt-get install chrome-gnome-shell\n```\n\n이제 Unite를 설치해주어야 하는데, Unite는 패키지 의존성이 있기 때문에 터미널에 다음과 같이 입력해서 패키지를 먼저 설치해줍니다.\n\n```\n$ sudo apt install x11-utils gnome-shell-extension-dashtodock\n```\n\n![](5.png)\n\n이제 Unite plugin을 설치해줄 차례입니다!\n\n[https://extensions.gnome.org/](https://extensions.gnome.org/)\n\n위 링크에 접속해줍니다. 그 후, Unite를 검색해서 설치해주면 됩니다.\n\n![](6.png)\n\nUnite를 눌러 들어가준 뒤, 아래 사진의 표시한 부분을 클릭하여 On으로 만들어줍니다.\n\n![](7.png)\n\n설치할 것이냐고 묻는 팝업창이 뜨고, 여기서 Install을 선택하게 되면,\n\n다음과 같이 Top Bar와 Title Bar, Menu Bar가 공간을 같이 사용하면서 차지하는 공간이 줄어들게 됩니다.\n\n![](8.png)\n\n어떤 차이인지 비교해볼까요?\n\n![](9.png)\n\n왼쪽에 있는 창이 Unite를 설치한 후의 모습이고, 오른쪽에 있는 창이 Unite를 설치하기 전의 모습입니다.\n\n실질적으로는 Title Bar 크기 만큼의 공간이 확보가 된 것인데, 이정도 크기 확보로도 전보다는 훨씬 시원시원한 느낌이 드는 것 같습니다.\n\n### 2. SleepMode 방지 - Caffeine\n\nUbuntu를 사용하다 보니, Ubuntu를 실행시키고 이것저것 검색하거나 글을 쓰다 들어오면,\n\n![](10.png)\n\n어느 순간 이렇게 위처럼 SleepMode가 되어 잠겨버리고 다시 로그인해야하는 상황이 종종 있었습니다.\n\n이게 또 생각보다 거슬릴 때가 많아서 방법을 모색하던 중, extension 설치를 통해 해결할 수 있다는 사실을 알았습니다.\n\n그 extension의 이름이 바로 Caffeine입니다. \n\nUbuntu를 잠들지 못하게 하겠다는 의지가 담긴 이름같습니다. ~~정말 이름한번 잘 지은 것 같습니다.~~\n\n![](11_1.png)\n\nUbuntu Software에서 우측 상단의 검색 버튼을 눌러 'Caffeine'을 검색한 후, 설치를 진행합니다.\n\n![](12.png)\n\n설치가 완료된후, Caffeine을 실행시키게 되면 우측 상단에 컵 모양 아이콘이 생기게 됩니다.\n\n![](13.png)\n\n이 아이콘을 클릭한 후 'Activate'를 선택하게 되면,\n\n![](14.png)\n\n다음과 같이 컵에서 김이 올라오며 실행된 것을 볼 수 있습니다.\n\n![](15.png)\n\n이렇게 실행해 두면 Ubuntu를 가만히 두더라도 SleepMode가 실행되지 않는 것을 확인했습니다\n\n더 이상 귀찮게 암호를 다시 입력해서 잠금을 해제해야하는 일이 생기지 않겠네요ㅎㅎ\n\n## 느낀 점\n\nUbuntu를 사용해보면서, 정말 많은 사람들이 함께 만들어가고 있다는 느낌을 받았습니다.\n\n무언가 사용하다 불편한 점이 있다고 한다면 인터넷 서칭을 하다보면 비슷한 불편함을 겪었던 사람들을 찾을 수 있고, 해결책 또한 쉽게 찾을 수 있다는 것이 정말 마음에 들었습니다.\n\n누군가 불편함을 느끼면 그것을 해결하기 위해 다함께 노력하고, 공유하는 그 시스템을 보고, 몸소 느끼면서 Linux의 매력을 알 수 있었던 한주였습니다.\n\n'Firefox 브라우저 디자인이 보기 안좋다! 이렇게 수정했으면 좋겠다'라는 의견이 있으면 그 문제를 해결하는 방법을 찾아내고 서로 공유했기에 제가 이렇게 쉽고 빠르게 해결 방안을 찾고 문제를 해결할 수 있었고,\n\n마찬가지로 'Ubuntu가 SleepMode에 들어가지 않았으면 좋겠다!'라는 의견이 있으면 그 문제를 해결하는 소프트웨어를 만들어내고 공유해서 많은 사람들이 쓸 수 있도록 했기 때문에 저는 간단하게 그 소프트웨어를 내려받음으로써 불편함을 해소할 수 있었습니다.\n\n이렇게 잘 구축된 운영체제와 커뮤니티가 서로 맞물려 상호작용하면서 긍정적인 작용을 하고있는 것을 느낄 수 있었습니다.\n\nLinux의 어찌보면 가장 두드러지는 특징이라고 할 수 있는 '오픈소스 소프트웨어'를 직접 체험해보고 몸소 장점을 느껴봤다는 점에서 의미있는 시간이었다고 생각합니다.\n\n---\n이번주는 Ubuntu를 사용하면서 불편한 점을 해소하는 방법을 알아봤다면,\n\n다음주부터는 간단한 코딩을 Ubuntu를 통해 해보거나 다른 응용프로그램들을 설치해서 직접 사용해보는 활동들을 주로 해보도록 하겠습니다.","excerpt":"2주차 Linux(Ubuntu)로 살아보기  18.04버전의 화면 모습입니다. 알아보니 원래 Ubuntu는 'GNOME'이라는 데스크탑 환경을 채택했다가, 'Unity'환경으로 바꾸었었고, 이제 다시 18.04버전부터 'Unity…","fields":{"slug":"/linux2/"},"frontmatter":{"date":"Mar 29, 2020","title":"Linux(Ubuntu)로 살아보기 (2) - Unite, Caffeine","tags":["Linux(Ubuntu)"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Linux로 살아보기\n\n'Linux로 살아보기'라는 과제를 받았습니다.\n\nLinux 운영체제를 설치하고, 그 위에서 직접 일주일에 한 개 이상씩의 프로그램들을 설치하고 실행시켜보면서 Linux라는 운영체제에 익숙해지는 것이 이 과제의 목표입니다.\n\n### 첫 번째 선택\n\nLinux를 설치하기 전, 첫번째로 선택해야하는 것은 'Linux를 메인 운영체제로 사용할 것이냐, 아니면 가상 머신을 통해 사용할 것이냐'입니다. \n\n저는 메인 운영체제로 macOS Catalina를 사용하고 있기 때문에 가상 머신을 통해 Linux를 사용하기로 했습니다.\n\n### 두 번째 선택\n\n가상 머신을 통해 Linux를 사용하기로 했으니, 어떤 가상머신을 통해 Linux를 설치할 것인지에 대해 생각을 해보아야 합니다.\n\n고려할수 있는 가상머신은 총 3개 정도였습니다.\n\n1. VirtualBox\n\n2. VMware Fusion\n\n3. Parallels Desktop\n\n#### 1. VirtualBox\n\nVirtualBox는 우선 공짜로 쓸 수 있다는 점에서 메리트가 있었지만, 사용할 수 있는 메모리와 프로세서 수, 그래픽메모리 용량 등에 제약이 많았습니다.\n\n간단한 동작을 수행하는데에도 눈에 거슬릴 정도로 많이 버벅이며 느리다는 생각이 들었습니다.\n\n#### 2. VMware Fusion\n\nVMware Fusion은 Parallels Desktop과 macOS의 가상머신 양대산맥으로 손꼽히는 프로그램입니다.\n\n하지만, 기능적인 측면에서 Parallels에 많이 밀린다는 느낌을 강하게 받았습니다.\n\n#### 3. Parallels Desktop\n\nParallels Desktop이 VMware Fusion보다 [기능이 많고](https://www.parallels.com/kr/landingpage/pd/fusion-compete/?gclid=Cj0KCQjw6_vzBRCIARIsAOs54z53ur3lxesgA0yBwiU8TOixP3TGoXNmc93yYwbI02PlTeSQX17rmfwaAnRsEALw_wcB) Parallels Tools를 이용한 다양한 기능들도 사용할 수 있었습니다.\n\n무엇보다도 이 혜택이 가장 큰 메리트가 아닐까 싶습니다.\n\n![](free.png)\n\n결과적으로 Parallels Desktop을 통해 Linux 설치를 진행하게 되었습니다.\n\n### 세 번째 선택\n\n이제는 어떤 종류의 Linux를 사용할지를 선택할 시간입니다.\n\n사실 이 선택이 가장 쉬웠습니다. 고려 대상은 다음과 같았습니다. \n\n1. 관련 Document가 많으며 정보를 쉽게 찾을 수 있는가?\n\n2. 설치 및 설정, 유지/보수가 간편한가?\n\n새로운 기술을 습득하고 학습함에 있어 매우 중요하다는 사실을 느낀 경험이 많기 때문에 널리 사용되며 커뮤니티도 많이 활성화된 Ubuntu를 사용하기로 결정했습니다.\n\n## 설치\n\n우선 다음과 같이 Parallels에서 Ubuntu를 바로 설치할 수도 있지만, 저는 iso 파일을 통해 따로 설치하겠습니다.\n\n![](1.png)\n\n[이 링크](https://ubuntu.com/download/desktop)를 통해 Ubuntu iso 파일을 내려받을 수 있습니다.\n\n링크로 들어가면 다음과 같은 화면이 나오는데, 저는 LTS 버전(Long-Term Service)을 설치해주도록 하겠습니다.\n\n![](install.png)\n\n제가 설치하는 날짜 기준 Ubuntu 18.04.4 LTS 버전이 배포되고 있으며, 배포 시작일로부터 5년(2023년 4월까지) 서비스를 해준다고 명시되어 있습니다.\n\n설치가 완료되면, Parallels에서 'DVD 또는 이미지 파일의 Windows나 다른 OS 설치'항목을 선택하여 설명대로 설치를 진행합니다.\n\n![](2.png)\n\n![](3.png)\n\n![](4.png)\n\n![](5.png)\n\n![](6.png)\n\n설치가 완료되었습니다! 그럼 기본 설정을 마저 해보도록 합시다.\n\n## 설정\n\nUbuntu의 전원을 종료한 뒤, Parallels 우클릭 후 제어 센터를 선택하면 다음과 같은 창이 나옵니다.\n\n![](7.png)\n\n여기서 톱니바퀴 모양을 눌러 설정을 해줍시다!\n\n![](8.png)\n\n여기에서 가상 머신의 CPU 및 메모리, 그래픽 등을 설정해줄 수 있습니다.\n\n![](9.png)\n\n하드웨어 - CPU 및 메모리 탭에서는 프로세서 수와 메모리를 설정해줄 수 있습니다.\n\n저는 총 12개의 프로세서 중 6개, 16GB의 메모리 중 8GB를 사용하기로 했습니다.\n\n![](10.png)\n\n하드웨어 - 그래픽 탭에서는 그래픽 메모리 값을 설정해줍니다. \n\n저는 최대 2GB중 1GB를 사용하기로 했습니다.\n\n위와 같이 설정을 마치고 나면, 보다 쾌적한 환경에서 Ubuntu를 실행할 수 있게 됩니다.\n\n## 느낀점\n\n무엇보다도, 설치를 하는 과정에서 Linux 운영체제가 그리 어렵지만은 않다는 생각이 들었다는 것이 가장 충격이었습니다.\n\n엄청 복잡하고 처음 시작하는 사람은 접근하기가 어렵다는 선입견을 가지고 있었는데, Ubuntu는 그 고정관념을 깨기에 충분했던 것 같습니다.\n\n다음 포스트부터는 한 주에 하나씩 Ubuntu에서 프로그램을 하나씩 설치하고 사용해가며 적응해야 할 텐데,\n\n그 과정이 생각보다 어렵고 힘들지만은 않을 것 같다는 희망이 생긴 것 같습니다.\n\n","excerpt":"Linux로 살아보기 'Linux로 살아보기'라는 과제를 받았습니다. Linux 운영체제를 설치하고, 그 위에서 직접 일주일에 한 개 이상씩의 프로그램들을 설치하고 실행시켜보면서 Linux…","fields":{"slug":"/UbuntuInstall/"},"frontmatter":{"date":"Mar 22, 2020","title":"Linux(Ubuntu)로 살아보기 (1) - 설치 및 설정","tags":["Linux(Ubuntu)"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## What is STL?\n\nSTL(Standard Template Library)는 표준 C++ Library입니다.\n\n프로그램에 필요한 자료구조와 알고리즘을 Template로 제공해줍니다.\n\n이 포스트에서 설명할 array Template는 STL에 Sequence Container(시퀀스 컨테이너)중 하나의 요소입니다.\n\nSTL Sequence Container에는 vector, array, deque, list, forward_list가 있습니다.\n\nSTL Container에 관한 더 자세한 설명은 [이 링크](https://docs.microsoft.com/ko-kr/cpp/standard-library/stl-containers?view=vs-2019)를 통해 볼 수 있습니다.\n\n\n## Why STL Array?\n\n[앞선 포스트](https://mintyu.github.io/cpp09/)에서 설명했듯, 이미 C++에는 C 스타일의 static array를 지원하고 있었습니다.\n\n하지만, 이 static array는 꽤나 사용하기 불편했습니다.\n\n불편한 이유는 다른 언어들을 조금만 둘러보아도 알 수 있습니다.\n\n대부분의 언어들은 배열을 선언할 때 배열에 대한 다양한 부가 정보들(length 등)을 사용할 수 있게 설계되어 있습니다.\n\n하지만, 기존의 static array는 단순히 연속된 메모리 공간의 앞부분을 가르키는 포인터에 불과 했었기 때문에 복잡한 과정을 통해 배열의 길이를 구해야만 했습니다.\n\n물론 vector가 있었긴 하지만, 성능 저하의 부담이 크고 잠재적인 문제가 존재했기 때문에 더 효율적인 array가 필요했습니다.\n\n그렇게 STL Sequence Container에 array가 추가되었습니다.\n\n이렇게 array는 vector보다 더 가볍고 빠르며 일부 STL 컨테이너를 사용할 수 있게 되었습니다.\n\n## array Class\n\narray를 사용하기 위해서는 우선 `#include <array>`로 array 헤더파일을 불러와야 합니다.\n\n그리고 array를 선언하기 위한 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> array<타입, 크기> 배열 이름; \n> // 선언 먼저 하는 경우\n> \n> array<타입, 크기> 배열 이름 = {원소1, 원소2, 원소3, ...};\n> // 선언과 동시에 초기화하는 경우\n> ```\n\n주의할 점은, 이 배열의 원형은 `std::array`이므로 직접 `std::`를 입력하거나 `using namespace std;`를 이용해야합니다.\n\n해당 포스트에서는 `using namespace std;`를 입력했다고 가정한 후 설명하겠습니다.\n\n> 예제\n> ``` cpp\n> array<int, 4> arr1 = {0, 1, 2, 3};\n>\n> array<int, 4> arr2 = {0, 1, 2};\n> // exactly same with {0, 1 ,2, 0}\n> \n> array<int, 4> arr3 = {0, 1, 2, 3, 4};\n> // not allowed\n> \n> array<int, > arr4 = {0, 1, 2, 3};\n> // not allowed\n> ```\n\n`arr1`과 같이 선언이 가능하며, `arr2`처럼 주어진 크기보다 적은 개수의 원소로 초기화해주었을 때, 부족한 만큼은 0으로 초기화됩니다.\n\n`arr3`과 같이 주어진 크기보다 많은 수의 원소는 대입할 수 없습니다.\n\n또한, [static array](https://mintyu.github.io/cpp09/)와는 다르게 `arr4`처럼 크기를 입력하지 않으면 오류가 발생합니다.\n\n### index 접근(at)\n\n이 array도 일반 static array처럼 `[ ]`를 통해 접근이 가능합니다.\n\n> ``` cpp\n> array<int, 4> arr1 = {0, 1, 2, 3};\n> \n> cout << array[1]; // 1\n> \n> array[2] = 4;\n> cout << array[2]; // 4\n> ```\n\n하지만, 이 문법의 문제는 유효 범위 검사를 하지 않는다는 점입니다.\n\n아래의 간단한 예제를 보도록 합시다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> using namespace std;\n> \n> int main()\n> {\n> \tint a;\n> \tcin >> a;\n> \tint arr[3]= {1, 2, 3};\n> \tcout << arr[a];\n> \treturn 0;\n> }\n> ```\n\n별 문제없이 잘 실행됩니다. 하지만 a에 입력값으로 3 이상의 수를 준다면?\n\n![](1.png)\n\n갑자기 이상한 값을 출력합니다.\n\n그 원인은 index가 범위를 벗어난 것을 검사하지 않고, 초기화되지 않은 메모리에 접근했기 때문입니다.\n\n이런 경우 프로그램이 커졌을 때, 오류를 따로 발생시키지 않게 되면 디버깅 작업이 상당히 까다로워집니다.\n\n따라서, 유효 범위를 검사해서 따로 예외를 발생시켜주는 `at( )`을 사용하여 접근하는 것이 더 안전합니다.\n\n물론, 유효 범위 검사를 진행하기 때문에 operator `[ ]`로 접근하는 것보다는 속도가 약간 느립니다.\n\n`at( )`은 다음과 같이 쓸 수 있습니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> #include <array>\n> \n> using namespace std;\n> \n> int main()\n> {\n> \tint a;\n> \tcin >> a;\n> \tarray<int, 3> arr = {1, 2, 3};\n> \tcout << arr.at(a);\n> \treturn 0;\n> }\n> ```\n\n앞서 operator로 접근한 예제와 같은 예제이지만, a에 3이상의 수를 입력하게 된다면?\n\n![](2.png)\n\n이처럼 at이 out\\_of\\_range 예외를 발생시켰습니다.\n\n이와 같은 접근 방식은 조금 더 안전한 코드를 만들 수 있습니다.\n\n### 배열의 길이(size)\n\n배열의 길이를 출력하는 방법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> 배열이름.size();\n> ```\n\nstatic array보다 훨씬 간단한 방법으로 배열의 길이를 출력할 수 있습니다.\n\n### 배열 정렬(sort)\n\n사실 정렬은 std::array에서 정의된 함수는 아니지만, 유용하게 사용할 수 있기 때문에 사용법을 알아두는것이 좋습니다.\n\n`sort( )`는 `#include <algorithm>`을 통해 헤더파일을 불러와야 사용할 수 있습니다.\n\n기본적으로 오름차순으로 정렬하게 됩니다.\n\n> 문법\n> ``` cpp\n> sort(배열의 첫번째를 가르키는 반복자, 배열의 마지막을 가르키는 반복자);\n> ```\n\nsort 함수는 다음과 같이 사용할 수 있습니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> #include <array>\n> #include <algorithm>\n> \n> using namespace std;\n> \n> int main()\n> {\n> \tarray<int, 5> arr = {7, 8, 1, 2, 3};\n> \tsort(arr.begin(), arr.end()); // sort arr\n> \tfor (int i = 0; i < 5; i++)\n> \t{\n> \t\tcout << arr[i] << \" \"; // 1 2 3 7 8\n> \t}\n> \t\n> \treturn 0;\n> }\n> ```\n\n`sort( )`의 인자로 준 값들은 반복자(iterator)를 의미합니다.\n\n이 예제에서는 배열의 정렬 시작과 끝 지점을 나타내는 용도로 사용되었습니다.\n\n`begin( )`과 `end( )`는 각각 배열의 첫 번째 반복자와 마지막 반복자를 리턴하는 기능이라는 것까지만 알아두어도 좋습니다.\n\n이 포스트에서는 \"array의 정렬이 가능하다!\" 까지만 이해해도 충분합니다.\n\n반복자(iterator)와 `sort( )`에 대한 설명은 다음에 더 자세히 하도록 하겠습니다.\n\n## Summary\n\n이번 포스트에서는 STL Sequence Container중 하나인 `std::array`, 즉 배열에 대해 알아보았습니다.\n\n또한, 이 배열의 값에 접근하고, 길이를 출력하고, 정렬하는 방법에 대해서도 알아보았습니다.\n\n이 `std::array`에 대한 더 자세한 정보는 [이 링크](https://docs.microsoft.com/ko-kr/cpp/standard-library/array-class-stl?view=vs-2019)를 통해 볼 수 있습니다.","excerpt":"What is STL? STL(Standard Template Library)는 표준 C++ Library입니다. 프로그램에 필요한 자료구조와 알고리즘을 Template로 제공해줍니다. 이 포스트에서 설명할 array Template는 STL…","fields":{"slug":"/cpp10/"},"frontmatter":{"date":"Mar 15, 2020","title":"바닥부터 시작하는 C++ (10) - 배열(STL)","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 배열(Array)\n\n배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의할 수 있습니다.\n\n배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 합니다.\n\nC++에서 인덱스는 언제나 0부터 시작하며, 0을 포함한 양의 정수만을 가질 수 있습니다.\n\n \n\n배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료 구조입니다.\n\n \n\n배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열뿐만 아니라 그 이상의 다차원 배열로도 선언할 수 있습니다.\n\n하지만 현실적으로 이해하기가 쉬운 2차원 배열까지가 많이 사용됩니다.\n\n### 배열 선언\n\n배열은 다음과 같이 선언할 수 있습니다.\n\n> 문법\n> ``` cpp\n> 타입 배열이름 [배열 길이];\n> ```\n\n변수와 마찬가지로 선언 후 따로 초기화해줄 수도 있으며, 선언과 동시에 초기화해줄 수도 있습니다.\n\n> 예제\n> ``` cpp\n> // 선언 후 초기화\n> int arr1[3];\n> \n> arr[0] = 1;\n> arr[1] = 2;\n> arr[2] = 3;\n> \n> // 선언과 동시에 초기화\n> int arr2[3] = {11, 22, 33};\n> \n> int arr3[3];\n> arr3[3] = {111, 222, 333}; // 오류 발생!\n>\n> int arr0[3] = { }; // int arr0[3] = {0, 0, 0}와 같다\n> \n> ```\n\n주의할 점은, `arr3`처럼 배열을 선언해놓은 후 `arr3[3] = {111, 222, 333}`처럼 초기화는 불가능합니다. \n\nCurly Bracket(`{ }`)으로 초기화하려면 선언과 동시에 초기화해주어야 합니다.\n\n뿐만 아니라, `arr1`과 `arr2`의 index 크기가 같다고 해서 다음과 같이 대입할 수 없습니다.\n\n`arr0`처럼 빈 괄호(`{ }`)로 배열을 초기화하면 모든 항목이 0으로 초기화됩니다.\n\n``` cpp\narr1 = arr2 // 오류 발생!\n```\n\n### 배열의 길이 \n\n배열의 길이, 즉 원소의 개수를 구하는 방법은 다음과 같습니다.\n\n``` cpp\nsizeof(배열 이름) / sizeof(배열 이름[0])\n```\n\n여기서 `sizeof(arg)`함수는 arg의 크기를 byte로 반환하는 함수입니다.\n\n따라서 `sizeof(배열 이름)`은 배열 전체에 할당된 메모리의 크기를 나타내며, `sizeof(배열이름[0])`은 첫번째 인덱스에 있는 요소의 크기를 나타냅니다.\n\n배열에는 모두 같은 종류의 요소들이 들어가므로, `sizeof(배열 이름) / sizeof(배열 이름[0])`은 첫번째 인덱스와 같은 크기의 요소들이 배열에 총 몇개 존재하는지를 나타냅니다.\n\n\n그렇다면, 만약 다음처럼 index의 길이를 지정해주지 않으면 어떤 일이 일어날까요?\n\n``` cpp\nint noIndex[] = {0, 1, 2, 3, 4};\nint index = sizeof(noIndex) / sizeof(noIndex[0])\n\ncout << index // 5\n```\n\n이렇게 배열의 길이를 지정해주지 않게 되면, 배열의 요소 개수에 맞춰 자동으로 배열의 길이가 설정됩니다.\n\n## Array Template Class?\n\nC++11부터는 array의 템플릿 클래스가 추가되었습니다.\n\n`#include <array>`를 통해 기존 C 스타일이 아닌 새로운 형태로 더 간편하게 배열을 정의하고 이용할 수 있습니다.\n\n다음 포스트에서는 이 내용에 대해 다루도록 하겠습니다.","excerpt":"배열(Array) 배열(array)은 같은 타입의 변수들로 이루어진 유한 집합으로 정의할 수 있습니다. 배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 합니다. C…","fields":{"slug":"/cpp09/"},"frontmatter":{"date":"Mar 10, 2020","title":"바닥부터 시작하는 C++ (9) - 배열(C style)","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nMAC OS를 사용하는 경우, iTerm에서 VSCode를 간단한 명령어로 호출할 수 있습니다.\n\n다음과 같이 열고자 하는 디렉토리 내에서 `code .`라는 명령어를 입력해주면 현재 경로로 VSCode가 실행됩니다.\n\n![Terminalexample](1.png)\n\n## Setting\n\n하지만, 이를 위해선 간단한 세팅을 해 주어야 합니다.\n\n먼저, 현재 저는 iTerm2 Terminal에 oh-my-zsh를 사용하고 있음을 밝힙니다.\n\n저처럼 iTerm2에 oh-my-zsh 세팅까지 모두 끝냈다면 ~/.zshrc를 편집하는 방법은 알고 있겠지만, 모른다 하더라도 어렵지는 않습니다.\n\niTerm2 터미널을 열고, 다음과 같이 입력합니다.\n\n```\n$ vim ~/.zshrc\n```\n\n위 명령어를 입력했다면, 다음과 같은 화면을 볼 수 있습니다.\n\n![vim](2.png)\n\nShift + g를 눌러 문서의 맨 아래로 이동한 후, o(아랫줄에 insert)를 눌러 편집모드를 켭니다.\n\n그리고 다음과 같이 입력해줍니다.\n\n```\ncode () {VSCODE_CWD=\"$PWD\" open -n -b \"com.microsoft.VSCode\" --args $* ;}\n```\n\n입력이 되었다면, esc버튼을 눌러 편집 모드를 끝낸 뒤에(왼쪽 아래 normal 확인),\n\n:wq를 입력하여 저장하고 나가줍니다.(\":\"을 누르면 명령어 입력창이 활성화됩니다.)\n\n그 후 터미널에서 다음과 같이 `source ~/.zshrc`를 입력하면 터미널에서 명령어를 통해 VSCode를 실행할 수 있게 됩니다!\n\n![source](3.png)","excerpt":"MAC OS를 사용하는 경우, iTerm에서 VSCode를 간단한 명령어로 호출할 수 있습니다. 다음과 같이 열고자 하는 디렉토리 내에서 라는 명령어를 입력해주면 현재 경로로 VSCode가 실행됩니다.  Setting…","fields":{"slug":"/VSCodeShortCut/"},"frontmatter":{"date":"Mar 06, 2020","title":"iTerm(Using Zsh)에서 VSCode 열기 [MAC OS]","tags":["MAC","VSCode"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 반복문(Iteration Statements)\n\n반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문입니다.\n\n프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나입니다.\n\n \n\nC++에서 사용되는 대표적인 반복문의 형태는 다음과 같습니다.\n\n \n\n1. while 문\n\n2. do / while 문\n\n3. for 문\n\n4. 범위 기반의 for 문\n\n### while 문\n\nwhile 문은 특정 조건을 만족하는 한 계속해서 주어진 명령문을 반복 실행합니다.\n\n\nC++에서 while 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> while (조건식)\n> \n> {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n### do / while 문\n\nwhile 문은 루프에 진입하기 전에 먼저 조건식부터 검사합니다.\n\n하지만 do / while 문은 먼저 루프를 한 번 실행한 후에 조건식을 검사합니다.\n\n즉, do / while 문은 조건식의 결과와 상관없이 무조건 한 번은 루프를 실행합니다.\n\n \n\nC++에서 do / while 문의 문법은 다음과 같습니다.\n\n> 문법\n> ```cpp\n> do {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> } while (조건식);\n> ```\n\n### for 문\n\nwhile 문은 우선 조건식이 참(true)인지를 판단하여, 참이면 내부의 명령문을 실행합니다.\n\n내부의 명령문을 전부 실행하고 나면, 다시 조건식으로 돌아와 또 한 번 참인지를 판단하게 됩니다.\n\nfor 문은 while 문과는 달리 자체적으로 초기식, 조건식, 증감식을 모두 포함하고 있는 반복문입니다.\n\n따라서 while 문보다는 좀 더 간결하게 반복문을 표현할 수 있습니다.\n\n \n\nC++에서 for 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> for (초기식; 조건식; 증감식)\n> \n> {\n> \n>     조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n### 범위 기반의 for 문\n\nC++11부터는 범위 기반의 for 문이라는 새로운 형태의 반복문이 추가되었습니다.\n\n범위 기반의 for 문은 표현식 안에 포함되어 있는 모든 값에 대해 한 번씩 루프를 실행해 줍니다.\n\n \n\n이러한 범위 기반의 for 문은 배열을 자동으로 인식하며, 컨테이너 클래스에서 많이 사용됩니다.\n\n \n\n다음 예제는 범위 기반의 for 문을 사용하여 배열의 모든 값을 출력하는 예제입니다.\n\n> 예제\n> ```cpp\n> int arr[5] = {1, 3, 5, 7, 9};\n> \n>  \n> \n> for (int element : arr)\n> \n> {\n> \n>     cout << element << \" \";\n> \n> }\n> \n> // 1 3 5 7 9\n> ```\n\n\n## 루프 제어\n\n일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행합니다.\n\n하지만 continue 문과 break 문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 도와줍니다.\n\n\n### continue 문\n\ncontinue 문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 해줍니다.\n\n보통 반복문 내에서 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용됩니다.\n\n \n\n다음 예제는 1부터 100까지의 정수 중에서 짝수를 제외하고 홀수만을 출력하는 예제입니다.\n\n> 예제\n> ```cpp\n> int except_num = 2\n> \n>  \n> \n> for (int i = 0; i <= 100; i++)\n> \n> {\n> \n>     if (i % except_num == 0)\n> \n>     {\n> \n>         continue;\n> \n>     }\n> \n>     cout << i << \" \";\n> \n> }\n> // 1 3 5 7 9 ... 97 99\n> ```\n\n### break 문\n\nbreak 문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행합니다.\n\n즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용합니다.\n\n \n\n다음 예제는 1부터 사용자가 입력한 정수까지의 합을 구하는 예제입니다.\n \n> 예제\n> ```cpp\n> int num = 1, sum = 0;\n> int end_num = 10;\n> \n>  \n> \n> while (1) // 무한 루프\n> \n> {\n> \n>     sum += num;\n> \n>     if (num == end_num)\n> \n>     {\n> \n>         break;\n> \n>     }\n> \n>     num++;\n> \n> }\n> \n> cout << \"1부터 \" << end_num << \"까지 더한 값은 \" << sum << \"입니다.\";\n> \n> //1부터 10까지 더한 값은 55입니다.\n> ```\n\n","excerpt":"반복문(Iteration Statements…","fields":{"slug":"/cpp08/"},"frontmatter":{"date":"Mar 05, 2020","title":"바닥에서 시작하는 C++ (8) - 반복문","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"## 문제 정보\n\n#### 제한\n- 시간 제한 : 1초(추가 시간 없음)\n- 메모리 제한 : 128MB\n\n#### 알고리즘 분류\n- 수학\n- 구현\n\n## 문제\n\n피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.\n\n이를 식으로 써보면 F(n) = F(n-1) + F(n-2) (n>=2)가 된다.\n\nn = 17일때 까지 피보나치 수를 써보면 다음과 같다.\n\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597\n\nn이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 n이 주어진다. n은 45보다 작거나 같은 자연수이다.\n\n## 출력\n\n첫째 줄에 n번째 피보나치 수를 출력한다.\n\n#### <예제 입력 1>\n\n`10`\n\n#### <예제 출력 1>\n\n`55`\n\n## 풀이\n\n다이나믹 프로그래밍(DP)의 가장 대표적인 문제라고 할 수 있는 문제이다.\n\n규칙에 맞게 피보나치 수를 구해서 출력하기만 하면 되는 간단한 문제이다.\n\n피보나치 수는 앞의 두 수의 합이므로 `fib(a)`가 a번째 피보나치 수라고 가정하였을 때,\n\n`fib(a) = fib(a-1) + fib(a-2)`가 된다.\n\n따라서, 다음과 같이 재귀형으로 함수를 호출하며 피보나치 수를 구할 수 있다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint fib(int a) {\n\n    switch (a)\n    {\n\n    case 0:\n        return 0;\n        break;\n\n    case 1:\n        return 1;\n        break;\n\n\n    default:\n        return fib(a-1) + fib(a-2);\n        break;\n    }\n\n}\n\nint main() {\n\n    int a;\n\n    cin >> a;\n\n    cout << fib(a);\n\n    return 0;\n}\n```\n\n위 예제를 실행하고 `1, 2, 3, 4` 등을 입력하면 정상적으로 `1, 1, 2, 3`이 출력되는것을 확인할 수 있다.\n\n하지만, 문제의 입력 조건의 최댓값으로 주어진 `45`를 입력해보자.\n\n문제의 답이 출력되긴 하지만, 제한시간인 1초를 훨씬 넘겨서 뒤늦게 답이 출력되는 것을 볼 수 있다.\n\n따라서 위의 예제처럼 작성하여 제출하게 되면 다음처럼 제한시간이 초과된다.\n\n![시간 초과](1.png)\n\n그 이유는, 피보나치 수를 계산하는 과정에서 했던 계산을 계속하기 때문이다.\n\n`fib(10)`을 예로 들어보자.\n\n`fib(10) = fib(9) + fib(8)`\n\n`fib(10) = (fib(8) + fib(7)) + (fib(7) + fib(6))`\n\n`fib(10) = ((fib(7) + fib(6)) + (fib(6) + fib(5)) + ((fib(6) + fib(5)) + (fib(4) + fib(3))`\n\n`...후략`\n\n계산은 아직 절반도 하지 않았는데, `fib(8)`은 2번, `fib(7)`은 3번, `fib(6)`은 4번이나 호출되었다.\n\n시간이 초과되지 않기 위해서는, 조금 근본적인 방법으로부터 접근할 필요가 있다.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n\n    long long a[1000] = {0, 1, };\n\n    int count;\n\n    cin >> count;\n\n    for (int i = 2; i <= count; i++)\n    {\n\n        a[i] = a[i-1]+a[i-2];\n\n    }\n\n    cout << a[count];\n\n    return 0;\n}\n```\n\n위의 코드는 1차원 배열을 통해 함수를 재귀호출하지 않고 피보나치 수를 구한다.\n\n배열의 크기는 상관없기에 넉넉하게 잡았으며, 배열 안에 들어갈 수는 integer의 범위를 벗어날 수도 있기에 long long으로 설정해주었다.\n\n이 예제를 실행하고 45번째 피보나치 수를 구해도, 심지어 100번째 피보나치 수를 구한다 하더라도 즉각 답을 출력해주는 것을 볼 수 있다.\n","excerpt":"문제 정보 제한 시간 제한 : 1초(추가 시간 없음) 메모리 제한 : 128MB 알고리즘 분류 수학 구현 문제 피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음…","fields":{"slug":"/BOJ02747/"},"frontmatter":{"date":"Mar 02, 2020","title":"백준 [2747] - 피보나치 수(C++)","tags":["BOJ(C++)"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 조건문(Conditional Statements)\n\n조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문입니다.\n\n\nC++에서 사용하는 대표적인 조건문의 형태는 다음과 같습니다.\n\n \n\n1. if 문\n\n2. if / else 문\n\n3. if / else if / else 문\n\n4. switch 문\n\n### if 문\n\nif 문은 조건식의 결과가 참(true)이면 주어진 명령문을 실행하며, 거짓(false)이면 아무것도 실행하지 않습니다.\n\nC++에서 if문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식)\n> \n> {\n> \n>     조건식의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n위의 코드에서 블록에 속한 명령문은 중괄호({})를 기준으로 오른쪽으로 들여쓰기가 되어 있는 것을 볼 수 있습니다.\n\n이처럼 들여쓰기를 통해 코드의 가독성을 높이는 것을 인덴트(indent)라고 하며, 될 수 있으면 모든 코드를 인덴트하는 것이 좋습니다.\n\n### if / else 문\n\nif 문과 함께 사용하는 else 문은 if 문과는 반대로 주어진 조건식의 결과가 거짓(false)이면 주어진 명령문을 실행합니다.\n\n\nC++에서 if / else 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식)\n> \n> {\n> \n>     조건식의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else\n> \n> {\n> \n>     조건식의 결과가 거짓일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n위 식은 [여기](https://mintyu.github.io/cpp06/#%EC%82%BC%ED%95%AD-%EC%97%B0%EC%82%B0%EC%9E%90ternary-operator)에 설명했듯 아래 식처럼 삼항연산자를 통해 짧게 나타낼 수도 있습니다.\n> ``` cpp\n> 조건식 ? 반환값1(True) : 반환값2(False)\n> \n> ```\n\n### if / else if / else 문\n\nif / else if / else 문은 마치 새로운 구문처럼 보이지만, 사실은 두 개의 if / else 문이 연달아 나온 것뿐입니다.\n\n이러한 if / else if / else 문은 조건식을 여러 개 명시할 수 있으므로 중첩된 if 문을 좀 더 간결하게 표현할 수 있습니다.\n\nif / else if / else 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> if (조건식1)\n> \n> {\n> \n>     조건식1의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else if (조건식2)\n> \n> {\n> \n>     조건식2의 결과가 참일 때 실행하고자 하는 명령문;\n> \n> }\n> \n> else\n> \n> {\n> \n>     조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 명령문;\n> \n> }\n> ```\n\n**실행될 명령어가 한줄 뿐이라면 중괄호`{ }`를 생략해서 쓸 수 있습니다.**\n\n### switch 문\n\nswitch 문은 if / else 문과 마찬가지로 주어진 조건 값의 결과에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문입니다.\n\n이러한 switch 문은 if / else 문보다 가독성이 더 좋으며, 컴파일러가 최적화를 쉽게 할 수 있어 속도 또한 빠른 편입니다.\n\n하지만, switch 문의 조건 값으로는 char형, short형, int형 변수나 리터럴과 나중에 배우게 될 열거체까지 사용할 수 있습니다.\n\n따라서 if / else 문보다는 사용할 수 있는 상황이 적은 편입니다.\n\nC++에서 switch 문의 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> switch (조건 값)\n> \n> {\n> \n>     case 값1:\n> \n>         조건 값이 값1일 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n>     case 값1:\n> \n>         조건 값이 값2일 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n>     ...\n> \n>     default:\n> \n>         조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 명령문;\n> \n>         break;\n> \n> }\n> ```\n\ndefault 절은 조건 값이 위에 나열된 어떠한 case 절에도 해당하지 않을 때만 실행됩니다.\n\n이 절은 반드시 존재해야 하는 것은 아니며 필요할 때만 선언할 수 있습니다.\n\n또한, default 절의 위치가 꼭 switch 문의 맨 마지막일 필요는 없습니다.\n\n> 예제\n> ``` cpp\n> switch (num)\n> \n> {\n> \n>     case 1:\n> \n>         cout << \"입력하신 수는 1입니다.\" << endl;\n> \n>         break;\n> \n>     case 2:\n> \n>         cout << \"입력하신 수는 2입니다.\" << endl;\n> \n>         break;\n> \n>     case 3:\n> \n>         cout << \"입력하신 수는 3입니다.\" << endl;\n> \n>         break;\n> \n>     case 4:\n> \n>         cout << \"입력하신 수는 4입니다.\" << endl;\n> \n>         break;\n> \n>     case 5:\n> \n>         cout << \"입력하신 수는 5입니다.\" << endl;\n> \n>         break;\n> \n>     default:\n> \n>         cout << \"1부터 5까지의 수만 입력해 주세요!\" << endl;\n> \n>         break;\n> \n> }\n> ```\n\n각 case 절 및 default 절은 반드시 break 키워드를 포함하고 있어야 합니다.\n\nbreak 키워드는 조건 값에 해당하는 case 절이나 default 절이 실행된 뒤에 전체 switch 문을 빠져나가게 해줍니다.\n\n만약에 break 키워드가 없다면, 조건에 해당하는 switch 문의 case 절 이후의 모든 case 절이 전부 실행될 것입니다.","excerpt":"조건문(Conditional Statements) 조건문은 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문입니다. C++에서 사용하는 대표적인 조건문의 형태는 다음과 같습니다. if 문 if / else 문 if / else if…","fields":{"slug":"/cpp07/"},"frontmatter":{"date":"Feb 29, 2020","title":"바닥에서 시작하는 C++ (7) - 조건문","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 연산자(Operator)\n\nC++은 여러 종류의 연산을 위해 다양한 연산자(operator)를 제공하고 있습니다. \n\n\n### 산술연산자(Arithmetic Operator)\n\n| 산술 연산자 |                                설명                                |\n|:-----------:|:------------------------------------------------------------------:|\n|      +      | 왼쪽의 피연산자에 오른쪽의 피연산자를 더함.                        |\n|      -      | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺌.                        |\n|      *      | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱함.                        |\n|      /      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눔.                        |\n|      %      | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 반환함. |\n\n> 예제\n> ``` cpp\n> int num1 = 10;\n> \n> int num2 = 4;\n> \n>  \n> \n> cout << \"+ 연산자에 의한 결괏값은 \" << num1 + num2 << \"입니다.\" << endl;\n> // + 연산자에 의한 결괏값은 14입니다.\n> \n> cout << \"- 연산자에 의한 결괏값은 \" << num1 - num2 << \"입니다.\" << endl; \n> // - 연산자에 의한 결괏값은 6입니다.\n> \n> cout << \"* 연산자에 의한 결괏값은 \" << num1 * num2 << \"입니다.\" << endl; \n> // * 연산자에 의한 결괏값은 40입니다.\n> \n> cout << \"/ 연산자에 의한 결괏값은 \" << num1 / num2 << \"입니다.\" << endl; \n> // / 연산자에 의한 결괏값은 2입니다.\n> \n> cout << \"% 연산자에 의한 결괏값은 \" << num1 % num2 << \"입니다.\"; \n> // % 연산자에 의한 결괏값은 2입니다.\n> ```\n\n\n### 대입 연산자(Assignment Operator)\n\n| 대입 연산자 |                                         설명                                         |\n|:-----------:|:------------------------------------------------------------------------------------:|\n|      =      | 왼쪽의 피연산자에 오른쪽의 피연산자를 대입함.                                        |\n|      +=     | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      -=     | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      *=     | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      /=     | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, </br>그 결괏값을 왼쪽의 피연산자에 대입함. |\n|      %=     | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, </br>그 나머지를 왼쪽의 피연산자에 대입함. |\n\n\n> 예제\n> ``` cpp\n> int num1 = 8;\n> \n> int num2 = 8;\n> \n> int num3 = 8;\n> \n>  \n> \n> num1 = num1 + 5;\n> \n> num2 += 5;\n> \n> num3 =+ 5;\n> \n>  \n> \n> cout << \"- 연산자에 의한 결괏값은 \" << num1 << \"입니다.\" << endl;\n> // -  연산자에 의한 결괏값은 13입니다.\n> \n> cout << \"+= 연산자에 의한 결괏값은 \" << num2 << \"입니다.\" << endl;\n> // += 연산자에 의한 결괏값은 13입니다.\n> \n> cout << \"=+ 연산자에 의한 결괏값은 \" << num3 << \"입니다.\";\n> // =+ 연산자에 의한 결괏값은 5입니다.\n> \n> ```\n\n\n\n**주의**\n\n위의 예제에서 num =+ 5 연산은 단순히 숫자 5를 변수 num3에 대입하는 연산이 되었습니다. </br>이처럼 복합 대입 연산자에서 연산자의 순서는 매우 중요하므로 주의를 기울여야 합니다.\n\n### 논리 연산자(Logical Operator)\n\n| 논리 연산자 |                               설명                               |\n|:-----------:|:----------------------------------------------------------------:|\n|      &&     |         논리식이 모두 참이면 1을 반환함. (논리 AND 연산)         |\n|      \\|\\|     |     논리식 중에서 하나라도 참이면 1을 반환함. (논리 OR 연산)     |\n|      !      | 논리식의 결과가 참이면 0을, 거짓이면 1을 반환함. (논리 NOT 연산) |\n\n> 예제\n> ``` cpp\n> int num1 = 3;\n> \n> int num2 = -7;\n> \n> bool result1, result2;\n> \n>  \n> \n> result1 = (num1 > 0) && (num1 < 5);\n> \n> result2 = (num2 < 0) || (num2 > 10);\n> \n>  \n> \n> cout << \"&& 연산자에 의한 결괏값은 \" << result1 << \"입니다.\" << endl;\n> // && 연산자에 의한 결괏값은 1입니다.\n> \n> cout << \"|| 연산자에 의한 결괏값은 \" << result2 << \"입니다.\" << endl;\n> // || 연산자에 의한 결괏값은 1입니다.\n> \n> cout << \" ! 연산자에 의한 결괏값은 \" << !result2 << \"입니다.\" << endl;\n> // ! 연산자에 의한 결괏값은 0입니다.\n> ```\n\n### 삼항 연산자(Ternary Operator)\n\n> 문법\n> ``` cpp\n> 조건식 ? 반환값1(True) : 반환값2(False)\n> \n> ```\n\n물음표(?) 앞의 조건식에 따라 결괏값이 참(true)이면 반환값1을 반환하고, 결괏값이 거짓(false)이면 반환값2를 반환합니다.\n\n조건문과 같은 방식으로 쓰이며 이를 다음과 같이 조건문으로 바꾸어 쓸 수도 있지만, 조건문에 대한 자세한 내용은 후술하도록 하겠습니다.\n\n> ``` cpp\n> if (조건식)\n> \n> {\n>     반환값1(True)\n> }\n> \n> else\n> {\n>     반환값2(False)\n> }\n> ```","excerpt":"연산자(Operator) C++은 여러 종류의 연산을 위해 다양한 연산자(operator)를 제공하고 있습니다.  산술연산자(Arithmetic Operator…","fields":{"slug":"/cpp06/"},"frontmatter":{"date":"Feb 27, 2020","title":"바닥에서 시작하는 C++ (6) - 연산자(Operator)","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 상수\n\n상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미합니다.\n\n하지만 상수가 변수와 다른 점은 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다는 점입니다.\n\nC++에서 상수는 표현 방식에 따라 다음과 같이 나눌 수 있습니다.\n\n \n\n1. 리터럴 상수(literal constant)\n\n2. 심볼릭 상수(symbolic constant)\n\n## 리터럴 상수\n\n리터럴(Literal)은 변수에 넣는 변하지 않는 데이터를 말합니다.\n> ``` cpp\n> a = 5;\n> ```\n\n이 코드에서 5는 리터럴 상수입니다.\n\n리터럴 상수는 정수, 부동 소수점, 문자, 문자열, Boolean, 포인터 및 사용자가 정의한 리터럴로 분류 할 수 있습니다.\n\n### 정수 숫자\n> ``` cpp\n> 231\n>\n> 5542\n>\n> -43\n> ```\n\n정숫값을 식별하는 숫자 상수입니다. 인용 부호나 다른 특수 문자로 묶여 있지 않습니다.\n\n231은 문자 그대로 항상 231이라는 수 자체를 나타냅니다.\n\n\n### 부동 소수점 숫자\n\n소수점과 지수로 실제 값을 표현합니다.\n\n> ``` cpp\n> 3.14159    // 3.14159\n>\n> 6.02e23    // 6.02 x 10^23\n>\n> 1.6e-19    // 1.6 x 10^-19\n>\n> 3.0        // 3.0\n> ```\n\n### 문자 및 문자열 리터럴\n\n문자 및 문자열 리터럴은 따옴표로 묶습니다.\n\n> ``` cpp\n> 'z'\n> \n> 'q'\n> \n> \"Hello world\"\n> \n> \"KHU Software Convergence\"\n> \n> ```\n\n처음 두 표현식은 단일 문자 리터럴을 나타내고, 다음 두 표현식은 여러 문자로 구성된 문자열 리터럴을 나타냅니다.\n\n단일 문자를 나타내려면 작은 따옴표(`'`)로 묶고 문자열을 나타내려면 큰따옴표(`\"`)로 문자를 묶습니다.\n\n### 그 외의 리터럴\n\nC++에는 세 가지 키워드 리터럴(true, false, nullptr)이 있습니다.\n\n- bool 유형의 변수에는 true와 false만 사용이 가능합니다.\n- nullptr은 null 포인터 값 입니다.\n\n## 상수 표현식\n\n다음처럼 `const`를 사용하여 상수를 정의할 수도 있습니다.\n\n``` cpp\nconst double pi = 3.1415926;\n\nconst char tab = '\\t';\n```\n\n## 전처리기 정의 (#define)\n\n> ``` cpp\n> #define PI 3.14159\n> \n> #define NEWLINE '\\n'\n> ```\n\n**\\#define은 전 처리기 지시문이며, 끝에 세미콜론(`;`)이 필요하지 않습니다.**","excerpt":"상수 상수(constant)란 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간을 의미합니다. 하지만 상수가 변수와 다른 점은 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다는 점입니다. C…","fields":{"slug":"/cpp05/"},"frontmatter":{"date":"Feb 23, 2020","title":"바닥부터 시작하는 C++ (5) - 상수","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 변수(Variable)\n\n변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미합니다.\n\n즉, 변수란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하며, 이렇게 저장된 값은 변경될 수 있습니다.\n\n \n\nC++에서 숫자 표현에 관련된 변수는 정수형 변수와 실수형 변수로 구분할 수 있습니다.\n\n또다시 정수형 변수는 char형, int형, long형, long long형 변수로, 실수형 변수는 float형, double형 변수로 구분됩니다.\n\n## 변수의 이름 생성 규칙\n\nC++에서는 변수의 이름을 비교적 자유롭게 지을 수 있습니다.\n\n변수의 이름은 해당 변수에 저장될 데이터의 의미를 잘 나타내도록 짓는 것이 좋습니다.\n\n \n\nC++에서 변수의 이름을 생성할 때 반드시 지켜야 하는 규칙은 다음과 같습니다.\n\n \n1. 변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성됩니다.\n\n2. 변수의 이름은 숫자로 시작될 수 없습니다.\n\n3. 변수의 이름 사이에는 공백을 포함할 수 없습니다.\n\n4. 변수의 이름으로 C++에서 미리 정의된 키워드(keyword)는 사용할 수 없습니다.\n\n5. 변수 이름의 길이에는 제한이 없습니다.\n\n**C++은 변수의 이름에 대소문자를 구분합니다!**\n\n## 변수와 메모리 주소\n\n변수는 기본적으로 메모리의 주소(address)를 기억하는 역할을 합니다.\n\n메모리 주소란 물리적인 메모리 공간을 서로 구분하기 위해 사용되는 일종의 식별자입니다.\n\n즉, 메모리 주소란 메모리 공간에서의 정확한 위치를 식별하기 위한 고유 주소를 의미합니다.\n\n \n\n변수를 참조할 때는 메모리의 주소를 참조하는 것이 아닌, 해당 주소에 저장된 데이터를 참조하게 됩니다.\n\n따라서 변수는 데이터가 저장된 메모리의 주소뿐만 아니라, 저장된 데이터의 길이와 형태에 관한 정보도 같이 기억해야 합니다.\n\n \n\n다음 그림은 메모리상에 변수가 어떤 식으로 저장되는지를 보여줍니다.\n\n![변수 저장 방법](1.png)\n\n이 내용은 포인터의 개념을 이해하기 위해 필요한 개념이므로 익혀두는 것이 좋습니다.\n\n## 변수의 선언\n\nC++에서는 변수를 사용하기 전에 반드시 먼저 해당 변수를 저장하기 위한 메모리 공간을 할당받아야 합니다.\n\n이렇게 해당 변수만을 위한 메모리 공간을 할당받는 행위를 변수의 선언이라고 부릅니다.\n\n \n\nC++에서 변수를 선언하는 방법에는 다음과 같이 두 가지 방법이 있습니다.\n\n \n\n1. 변수의 선언만 하는 방법\n\n2. 변수의 선언과 동시에 초기화하는 방법\n\n### 변수의 선언만 하는 방법\n\n이 방법은 먼저 변수를 선언하여 메모리 공간을 할당받고, 나중에 변수를 초기화하는 방법입니다.\n\n하지만 이렇게 선언만 된 변수는 초기화하지 않았기 때문에 해당 메모리 공간에는 알 수 없는 쓰레깃값만이 들어가 있습니다.\n\n따라서 초기화하지 않은 변수는 절대로 사용해서는 안 됩니다.\n> 문법\n> ``` cpp\n> 타입 변수이름;\n> ```\n\n다음의 예제와 같이 먼저 변수를 선언해둔 뒤 나중에 초기화해줄 수 있습니다.\n\n> 예제\n> ``` cpp\n> int num;\n> \n> ...\n> \n> num = 20;\n> ```\n\n\n### 변수의 선언과 동시에 초기화하는 방법\n\nC++에서는 변수의 선언과 동시에 그 값을 초기화할 수 있습니다.\n\n또한, 선언하고자 하는 변수들의 타입이 같다면 이를 동시에 선언할 수 있습니다.\n\n> 문법\n> ``` cpp\n> \n> 타입 변수이름[, 변수이름];\n> \n> 타입 변수이름 = 초깃값[, 변수이름 = 초깃값];\n> \n> ```\n\n> 예제\n> ``` cpp\n> int num1, num2;\n> \n> double num3 = 1.23, num4 = 4.56;\n> ```\n","excerpt":"변수(Variable) 변수(variable)란 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미합니다. 즉, 변수란 데이터(data…","fields":{"slug":"/cpp04/"},"frontmatter":{"date":"Feb 20, 2020","title":"바닥부터 시작하는 C++ (4) - 변수","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## iostream(Input/Output Stream)\n\n사용자가 프로그램과 대화하기 위해서는 사용자와 프로그램 사이의 입출력을 담당하는 수단이 필요합니다.\n\nC++의 모든 것은 객체로 표현되므로, 입출력을 담당하는 수단 또한 C언어의 함수와는 달리 모두 객체입니다.\n\n \n\nC언어의 printf() 함수나 scanf() 함수처럼 C++에서도 **iostream 헤더 파일에 표준 입출력 클래스를 정의**하고 있습니다.\n\nC++에서는 **cout 객체로 출력** 작업을, **cin 객체로 입력** 작업을 수행하고 있습니다.\n\n \n\n또한, C++에서는 기존의 C언어 스타일처럼 printf() 함수나 scanf() 함수로도 입출력 작업을 수행할 수 있습니다.\n\n## cout 객체\n\ncout 객체는 다양한 데이터를 출력하는 데 사용되는 C++에서 미리 정의된 출력 스트림을 나타내는 객체입니다.\n\ncout 객체를 사용하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> std::cout << 출력할 데이터;\n> ```\n\n삽입 연산자(<<)는 오른쪽에 위치한 출력할 데이터를 출력 스트림에 삽입합니다.\n\n이렇게 출력 스트림에 삽입된 데이터는 스트림을 통해 출력 장치로 전달되어 출력됩니다.\n\n``` cpp\ncout << \"Hello World!\"; // Hello World!\n```\n\n## cin 객체\n\ncin 객체는 다양한 데이터를 입력받는 데 사용되는 C++에서 미리 정의된 입력 스트림을 나타내는 객체입니다.\n\ncin 객체를 사용하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> std::cin >> 저장할 변수;\n> ```\n추출 연산자(>>)를 통해 사용자가 입력한 데이터를 입력 스트림에서 추출하여, 오른쪽에 위치한 변수에 저장합니다.\n\n이때 cin 객체는 자동으로 사용자가 입력한 데이터를 오른쪽에 위치한 변수의 타입과 동일하게 변환시켜 줍니다.\n\n**주의 : cout과 cin의 화살표 방향이 서로 다릅니다!**\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> using namespace std;\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     int age;\n> \n>  \n> \n>     cout << \"나이를 입력해 주세요 : \";\n> \n>     cin >> age;\n> \n>  \n> \n>     cout << age << \"살 입니다.\" << endl;\n> \n>     return 0;\n> \n> }\n> ```\n\n위의 예제에서 여러분이 입력한 데이터는 자동으로 정수를 저장할 때 사용하는 타입으로 변환될 것입니다.\n\n만약에 문자열을 입력하면 cin 객체는 변수 age에 숫자가 아니라는 의미인 0을 전달할 것입니다.\n\n## C언어 표준 입출력 함수와의 차이점\n\nC언어 표준 입출력 함수인 printf() 함수나 scanf() 함수와 C++ 표준 입출력 객체와의 차이점은 다음과 같습니다.\n\n \n\n1. 삽입 연산자(<<)와 추출 연산자(>>)가 데이터의 흐름을 나타내므로 좀 더 직관적입니다.\n\n2. C++ 표준 입출력 객체는 입출력 데이터의 타입을 자동으로 변환시켜주므로 더욱 편리하고 안전합니다.\n\n","excerpt":"iostream(Input/Output Stream) 사용자가 프로그램과 대화하기 위해서는 사용자와 프로그램 사이의 입출력을 담당하는 수단이 필요합니다. C++의 모든 것은 객체로 표현되므로, 입출력을 담당하는 수단 또한 C…","fields":{"slug":"/cpp03/"},"frontmatter":{"date":"Feb 18, 2020","title":"바닥부터 시작하는 C++ (3) - iostream","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 네임스페이스(Namespace)\n\n네임스페이스란 이름이 기억되는 영역을 뜻하며, 이름이 소속된 공간을 의미합니다.\n\n네임스페이스는 C++ 프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해 주는 방법을 제공합니다.\n\n이러한 네임스페이스는 C언어에는 없는 C++ 만의 새로운 기능입니다.\n\n \n\nC++ 프로그램의 표준 구성 요소인 클래스, 함수, 변수 등은 std라는 이름 공간에 저장되어 있습니다.\n\n따라서 C++ 프로그램에서 표준 헤더 파일인 iostream 내의 정의를 사용하려면 다음과 같이 사용해야 합니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     std::cout << TEXT;\n> \n>     return 0;\n> \n> }\n> ```\n\n위의 예제처럼 std라는 네임스페이스에 있는 정의를 사용하려면, std:: 접두어를 붙여 해당 정의가 std라는 네임스페이스에 있다는 것을 컴파일러에 알려줘야 합니다.\n\n \n\n이러한 네임스페이스에 속한 정의를 간단하게 사용하려면 다음과 같은 명령문을 추가하면 됩니다.\n\n> ``` cpp\n> using namespace std; // std라는 네임스페이스에 속한 정의들은 네임스페이스 이름을 붙이지 않아도 사용할 수 있음.\n> ```\n\n다음 예제는 앞서 살펴본 예제와 정확히 같은 동작을 수행합니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n> using namespace std;\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     cout << TEXT;\n> \n>     return 0;\n> \n> }\n> ```\n\n## 주석\n\n주석이란 코드에 대한 이해를 돕는 설명을 적거나 디버깅을 위해 작성하는 일종의 메모입니다.\n\nC++ 컴파일러는 주석은 무시하고 컴파일하므로, 실행 파일에서는 이러한 주석을 확인할 수 없습니다.\n\n \n\nC++에서 주석을 작성하는 문법은 다음과 같습니다.\n\n> 문법\n> ``` cpp\n> // 한 줄 주석\n> \n> /*\n> \n> 여러 줄 주석\n> \n> */\n> ```\n\nC++에서는 여러 줄 주석 안에 또 다른 한 줄 주석을 삽입할 수 있습니다.\n하지만 여러 줄 주석 안에 또 다른 여러 줄 주석은 중첩해서 삽입할 수는 없습니다.\n\n> ``` cpp\n> /*\n> \n> 여러 줄 주석\n> \n> //한 줄 주석 삽입 가능!\n>\n> */\n>\n> \n> /*\n> \n> 여러 줄 주석\n> \n> /*여러 줄 주석 삽입 불가*/\n>\n> */\n>\n> ```\n\n위의 예제 마지막 줄 */는 주석으로 처리되지 않은 것을 확인할 수 있습니다.","excerpt":"네임스페이스(Namespace) 네임스페이스란 이름이 기억되는 영역을 뜻하며, 이름이 소속된 공간을 의미합니다. 네임스페이스는 C++ 프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해 주는 방법을 제공합니다. 이러한 네임스페이스는 C…","fields":{"slug":"/cpp02/"},"frontmatter":{"date":"Feb 16, 2020","title":"바닥부터 시작하는 C++ (2) - 네임스페이스, 주석","tags":["C++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## C++의 특징\n\nC++이 프로그래밍 언어로써 가지는 특징은 다음과 같습니다.\n\n \n\n1. C++은 절차 지향적이며 구조적 프로그래밍 언어입니다.\n\n2. C++은 객체 지향 프로그래밍 언어입니다.\n\n3. C++은 일반화 프로그래밍 언어입니다.\n\n \n\n이처럼 C++은 세 가지 프로그래밍 방식을 모두 지원하는 언어이며, 따라서 다양한 방식으로 프로그램을 작성할 수 있습니다.\n\n또한, 다양한 시스템에서의 프로그래밍을 지원하는 유용하고도 강력한 클래스 라이브러리들이 아주 많이 제공됩니다.\n\n\n## 실행 파일 생성 과정\n\n![실행 파일 생성 과정](1.png)\n\n1. 소스 파일(source file)의 작성\n\n2. 선행처리기(preprocessor)에 의한 선행처리\n\n3. 컴파일러(compiler)에 의한 컴파일\n\n4. 링커(linker)에 의한 링크\n\n5. 실행 파일(executable file)의 생성\n\n## 기본 구조\n\n간단한 C++ 프로그램의 기본 구조는 다음과 같습니다.\n\n언제나 다음과 같이 구성되는 것은 아니지만 많은 C++ 프로그램이 이와 비슷한 형태로 구성됩니다.\n\n> 문법\n> ``` cpp\n> #include 문\n> \n> #define 문\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     명령문;\n> \n>     return 문;\n> \n> }\n> ```\n\n간단한 텍스트를 출력하는 예제는 다음과 같습니다.\n\n> 예제\n> ``` cpp\n> #include <iostream>\n> \n> #define TEXT \"Welcome to C++ Programming!!\"\n> \n>  \n> \n> int main()\n> \n> {\n> \n>     std::cout << TEXT; // Welcome to C++ Programming!!\n> \n>     return 0;\n> \n> }\n> ```\n\n### main() 함수\n\nC++ 프로그램은 가장 먼저 main() 함수를 찾고, 그곳에서부터 실행을 시작합니다.\n\n따라서 모든 C++ 프로그램은 반드시 하나의 main() 함수를 가지고 있어야 합니다.\n\n만약 main() 함수를 발견하지 못하면 C++ 컴파일러는 오류를 발생시킬 것입니다.\n\n### 명령문(Statement)\n\nC++ 프로그램의 동작을 명시하고, 이러한 동작을 컴퓨터에 알려주는 데 사용되는 문장을 명령문(statement)이라고 합니다.\n\n이러한 C++의 모든 명령문은 반드시 세미콜론(;)으로 끝나야 합니다.\n\n> ``` cpp\n> std::cout << \"C++ 프로그래밍\"; // 정상적으로 출력됨.\n> \n> std::cout << \"C++ 프로그래밍\"  // 오류가 발생함.\n> \n> ```\n\n### 반환문(Return)\n\n반환문은 함수의 종료를 의미하며, 함수를 호출한 곳으로 결괏값을 반환하는 역할을 합니다.\n\n특히 main() 함수가 반환되면, 프로그램 전체가 종료됩니다.\n\n### 선행처리문(Preprocess)\n\n\\#include 문과 #define 문은 모두 선행처리기에 의해 처리되는 선행처리문입니다.\n\n \n\n\\#include 문은 외부에 선언된 함수나 상수 등을 사용하기 위해서 헤더 파일의 내용을 현재 파일에 포함할 때 사용합니다.\n\nC언어에서는 헤더 파일에 .h 확장자를 사용했지만, C++에서는 헤더 파일의 확장자를 사용하지 않기로 합니다.\n\n따라서 기존 C언어 헤더 파일들의 이름 앞에 c를 추가하여 C++ 스타일의 헤더 파일로 변환하기도 합니다.\n> ``` cpp\n> #include <math.h> // C, C++ 모두 허용\n> \n> #include <cmath>  // C++에서만 허용\n> ```\n\n물론 원칙은 위와 같이 바뀌었지만 C++ 프로그램에서는 기존의 C언어 스타일로도 헤더 파일을 사용할 수 있습니다.\n\n\\#define 문은 함수나 상수를 단순화해주는 매크로를 정의할 때 사용합니다.","excerpt":"C++의 특징 C++이 프로그래밍 언어로써 가지는 특징은 다음과 같습니다. C++은 절차 지향적이며 구조적 프로그래밍 언어입니다. C++은 객체 지향 프로그래밍 언어입니다. C++은 일반화 프로그래밍 언어입니다. 이처럼 C…","fields":{"slug":"/cpp01/"},"frontmatter":{"date":"Feb 14, 2020","title":"바닥부터 시작하는 C++ (1) - 기본 특징","tags":["C++"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"]}